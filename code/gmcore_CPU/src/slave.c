#include <stdio.h>
#include <stdlib.h>
#include <simd.h>
#include <math.h>
#include "slave.h"

#include "CPE.h"
#include "slave_struct.h"
#include "physical_variable.h"
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))

__thread_local int fnx;
__thread_local int fny;
__thread_local int fnz;
__thread_local int hnx;
__thread_local int hny;
__thread_local int hnz;
__thread_local int ghx;
__thread_local int ghy;
__thread_local int ghz;

void global_prepare(void *_ptr){
  global_info *gi = (global_info*)(_ptr);
  fnx = gi->fnx;
  fny = gi->fny;
  fnz = gi->fnz;
  hnx = gi->hnx;
  hny = gi->hny;
  hnz = gi->hnz;
  ghx = gi->ghx;
  ghy = gi->ghy;
  ghz = gi->ghz;
}

static void CalcID(int *id, int *rid, int *cid, int *w, int *e, int *s, int *n, int mx, int my){
  *id = _MYID;
  *rid = ROW(_MYID);
  *cid = COL(_MYID);

  if ((*cid % mx) == 0) *w = -1;
  else *w = *id - 1;
  if ((*cid % mx) == (mx - 1)) *e = -1;
  else *e = *id + 1;
  if ((*rid % my) == 0) *s = -1;
  else *s = *id - 8;
  if ((*rid % my) == (my - 1)) *n = -1;
  else *n = *id + 8;
}

static void RoundRobin(int n, int p, int size, int *beg, int *end, int *len){
  int cur = 0;
  int i;
  int cursize;
  for (i = 0 ; i < p ; i++){
    if (size % (n - i) == 0) cursize = size / (n - i);
    else cursize = size / (n - i) + 1;
    size -= cursize;
    cur += cursize;
  }
  *beg = cur;
  if (size % (n - p) == 0) cursize = size / (n - p);
  else cursize = size / (n - p) + 1;
  *len = cursize;
  *end = *beg + cursize;
}

static void CalcRange(int id ,int rid, int cid, int nx,int ny, int nz, int mx, int my, int mz, \ 
                      int *xbeg, int *xend, int *xlen, int *ybeg, int *yend, int *ylen, int *zbeg, int *zend, int *zlen){
  int px,py,pz;
  pz = ((rid / my) * (8 / mx) + (cid / mx));
  RoundRobin(mz,pz,nz,zbeg,zend,zlen);
  py = rid % my;
  RoundRobin(my,py,ny,ybeg,yend,ylen);
  px = cid % mx;
  RoundRobin(mx,px,nx,xbeg,xend,xlen);
}

struct MeshVector3 disect(int inx, struct MeshVector6* loopinfo)
{
  int k, tmp, j, i;
  k = (inx % (loopinfo->lz));
  tmp = (inx / (loopinfo->lz));
  j = (tmp % (loopinfo->ly));
  tmp = (tmp / (loopinfo->ly));
  i = (tmp % (loopinfo->lx));
  return (struct MeshVector3){(i + (loopinfo->sx)),(j + (loopinfo->sy)),(k + (loopinfo->sz))};
}

struct Vector3 cartesian_transform(double lon, double lat)
{
  double cos_lat, x, y, z;
  cos_lat = cos(lat);
  x = ((6371220.0 * cos_lat) * cos(lon));
  y = ((6371220.0 * cos_lat) * sin(lon));
  z = (6371220.0 * sin(lat));
  return (struct Vector3){x,y,z};
}

struct Vector2 inverse_cartesian_transform(double x, double y, double z)
{
  double lon, lat;
  lon = atan2(y,x);
  lat = asin((z / 6371220.0));
  if ((lon < 0.0))
  {
    lon = (lon + 6.283185307179586);
  }
  return (struct Vector2){lon,lat};
}

struct Vector3 cross_product(struct Vector3* a, struct Vector3* b)
{
  struct Vector3 res;
  res = (struct Vector3){0,0,0};
  res.x = (((a->y) * (b->z)) - ((a->z) * (b->y)));
  res.y = (((a->z) * (b->x)) - ((a->x) * (b->z)));
  res.z = (((a->x) * (b->y)) - ((a->y) * (b->x)));
  return res;
}

struct Vector3 norm_vector(struct Vector3* v)
{
  struct Vector3 res;
  double sum;
  res = (struct Vector3){0,0,0};
  sum = ((((v->x) * (v->x)) + ((v->y) * (v->y))) + ((v->z) * (v->z)));
  sum = sqrt(sum);
  if ((sum != 0))
  {
    res.x = ((v->x) / sum);
    res.y = ((v->y) / sum);
    res.z = ((v->z) / sum);
  }
  return res;
}

double calc_sphere_angle(struct Vector3* a, struct Vector3* b, struct Vector3* c)
{
  struct Vector3 nab, nbc, ta, tb;
  double dot, res;
  nab = (struct Vector3){0,0,0};
  nbc = (struct Vector3){0,0,0};
  ta = (struct Vector3){0,0,0};
  tb = (struct Vector3){0,0,0};
  ta = cross_product(a,b);
  tb = cross_product(b,c);
  nab = norm_vector(&ta);
  nbc = norm_vector(&tb);
  dot = (((nab.x * nbc.x) + (nab.y * nbc.y)) + (nab.z * nbc.z));
  res = acos(-MAX(MIN(dot,1.0),-1.0));
  return res;
}

double calc_area(struct Vector3* x, struct Vector3* y, struct Vector3* z)
{
  int n;
  double res, angle;
  struct Vector3 vi, vip, vim;
  n = 3;
  res = 0.0;
  angle = 0.0;
  vi = (struct Vector3){(x->x),(y->x),(z->x)};
  vip = (struct Vector3){(x->y),(y->y),(z->y)};
  vim = (struct Vector3){(x->z),(y->z),(z->z)};
  angle = calc_sphere_angle(&vim,&vi,&vip);
  res = (res + angle);
  angle = calc_sphere_angle(&vi,&vip,&vim);
  res = (res + angle);
  angle = calc_sphere_angle(&vip,&vim,&vi);
  res = (res + angle);
  res = (pow(6371220.0,2) * (res - ((n - 2) * 3.141592653589793)));
  return res;
}

double calc_area_with_last_small_arc(struct Vector3* x, struct Vector3* y, struct Vector3* z)
{
  struct Vector3 xv, yv, zv;
  double res, lat0, lon1, lat1, lon2, dlon, area1, area2, area3;
  struct Vector2 lonlat0, lonlat1, lonlat2;
  xv = (struct Vector3){0,0,0};
  yv = (struct Vector3){0,0,0};
  zv = (struct Vector3){0,0,0};
  res = calc_area(x,y,z);
  lonlat0 = inverse_cartesian_transform((x->x),(y->x),(z->x));
  lat0 = lonlat0.y;
  lonlat1 = inverse_cartesian_transform((x->y),(y->y),(z->y));
  lon1 = lonlat1.x;
  lat1 = lonlat1.y;
  lonlat2 = inverse_cartesian_transform((x->z),(y->z),(z->z));
  lon2 = lonlat2.x;
  if ((lat1 == 0))
  {
    return res;
  }
  else
  {
    if ((lat0 > lat1))
    {
      dlon = (lon2 - lon1);
    }
    else
    {
      dlon = (lon1 - lon2);
    }
    if ((dlon < 0.0))
    {
      dlon = (dlon + 6.283185307179586);
    }
    xv.x = 0.0;
    yv.x = 0.0;
    if ((((lat0 * lat1) >= 0) && (fabs(lat0) > fabs(lat1))))
    {
      xv.y = (x->y);
      yv.y = (y->y);
      zv.y = (z->y);
      xv.z = (x->z);
      yv.z = (y->z);
      zv.z = (z->z);
    }
    else
    {
      xv.y = (x->z);
      yv.y = (y->z);
      zv.y = (z->z);
      xv.z = (x->y);
      yv.z = (y->y);
      zv.z = (z->y);
    }
    if ((lat1 > 0.0))
    {
      zv.x = 6371220.0;
      area1 = ((pow(6371220.0,2) * dlon) * (1.0 - sin(lat1)));
    }
    else
    {
      zv.x = -6371220.0;
      area1 = ((pow(6371220.0,2) * dlon) * (sin(lat1) + 1.0));
    }
    area2 = calc_area(&xv,&yv,&zv);
    area3 = (area1 - area2);
    if (((area3 < 0.0) && (fabs(area3) > 1e-10)))
    {
      area3 = 0;
    }
    if ((((lat0 * lat1) >= 0) && (fabs(lat0) > fabs(lat1))))
    {
      res = (res + area3);
    }
    else
    {
      res = (res - area3);
    }
    return res;
  }
}

double hybrid_coord_calc_ph(double hyam, double hybm, double phs)
{
  return (((hyam * (100000.0 - 219.4)) + (hybm * (phs - 219.4))) + 219.4);
}

double slave_hybrid_coord_calc_ph_lev(double hyai, double hybi, double phs)
{
  return (((hyai * (100000.0 - 219.4)) + (hybi * (phs - 219.4))) + 219.4);
}

double slave_hybrid_coord_calc_dphdt_lev(double hybi, double dphsdt)
{
  return (hybi * dphsdt);
}

double specific_humidity(double qv)
{
  return (qv / (1 + qv));
}

double mixing_ratio(double sh)
{
  return (sh / (1 - sh));
}

double sign(double x, double y)
{
  if ((y > 0.0))
  {
    return x;
  }
  else
  {
    return -x;
  }
}

double potential_temperature(double t, double p, double qv)
{
  return ((t * pow((100000.0 / p),0.2858964143426295)) * (1 + (1.607779403567447 * qv)));
}

double slave_temperature(double pt, double p, double qv)
{
  return ((pt * pow((p / 100000.0),0.2858964143426295)) / (1 + (1.607779403567447 * qv)));
}

double virtual_temperature(double t, double sh)
{
  return (t * (1 + ((1.607779403567447 - 1) * sh)));
}

double dry_air_density(double pt, double p)
{
  return (((100000.0 / 287.04) / pt) * pow((p / 100000.0),0.7141434262948207));
}

double moist_air_density(double t, double p, double qv)
{
  return ((p / 287.04) / virtual_temperature(t,specific_humidity(qv)));
}

double upwind1(double dir, double wgt, double f1, double f2)
{
  return ((0.5 * (f2 + f1)) - (((0.5 * (f2 - f1)) * wgt) * dir));
}

double slave_upwind3(double dir, double wgt, double f1, double f2, double f3, double f4)
{
  double c31, c32, c33;
  c31 = (7.0 / 12.0);
  c32 = (-1.0 / 12.0);
  c33 = (1.0 / 12.0);
  return (((c31 * (f3 + f2)) + (c32 * (f4 + f1))) + (((c33 * ((f4 - f1) - (3 * (f3 - f2)))) * wgt) * dir));
}

double slope(double fm1, double f, double fp1)
{
  double df, df_min, df_max;
  df = ((fp1 - fm1) * 0.5);
  df_min = (2 * (f - MIN(MIN(fm1,f),fp1)));
  df_max = (2 * (MAX(MAX(fm1,f),fp1) - f));
  return sign(MIN(fabs(df),MIN(df_min,df_max)),df);
}

struct Vector3 slave_ppm(double fm2, double fm1, double f, double fp1, double fp2)
{
  double dfl, df, dfr, fl, fr, f6;
  dfl = slope(fm2,fm1,f);
  df = slope(fm1,f,fp1);
  dfr = slope(f,fp1,fp2);
  fl = ((0.5 * (fm1 + f)) + ((dfl - df) / 6.0));
  fr = ((0.5 * (fp1 + f)) + ((df - dfr) / 6.0));
  fl = (f - sign(MIN(fabs(df),fabs((fl - f))),df));
  fr = (f + sign(MIN(fabs(df),fabs((fr - f))),df));
  f6 = ((6 * f) - (3 * (fl + fr)));
  df = (fr - fl);
  return (struct Vector3){fl,df,f6};
}




























void c2a_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  c2a_0_0_info *data = (c2a_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu = data->stateu;
  __attribute__ ((aligned (32))) double stateu[10][258];
  
  double *_statev = data->statev;
  __attribute__ ((aligned (32))) double statev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu[j][i] = (0.5 * (stateu_lon[j][i] + stateu_lon[j][(i - 1)]));
            statev[j][i] = (0.5 * (statev_lat[j][i] + statev_lat[(j - 1)][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void calc_ph_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_0_info *data = (calc_ph_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statephs = data->statephs;
  __attribute__ ((aligned (32))) double statephs[10][258];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_1_info *data = (calc_ph_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_stateph_exn_lev = data->stateph_exn_lev;
  __attribute__ ((aligned (32))) double stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_exn_lev[j][i] = pow(stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_2_info *data = (calc_ph_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            stateph[k][i] = (0.5 * (stateph_lev[k][i] + stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_0_info *data = (calc_m_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][258];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem[k][i] = (stateph_lev[swindex[(k + 1)]][i] - stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_1_info *data = (calc_m_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_2_info *data = (calc_m_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[8][256];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[8][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[j][i] = (stateph[swindex[j]][i] - stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_3_info *data = (calc_m_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph_lev[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_0_0_info *data = (averageCellToLonEdge_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lon[j][i] = ((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_0_0_info *data = (averageCellToLatEdge_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lat[j][i] = ((statem[swindex[j]][i] + statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_0_0_info *data = (interpCellToVtx_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_vtx[j][i] = ((((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((statem[swindex[(j + 1)]][i] + statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_t_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_t_0_0_info *data = (calc_t_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[12][260];
  
  double *_stateqv = data->stateqv;
  __attribute__ ((aligned (32))) double stateqv[12][260];
  
  double *_statet = data->statet;
  __attribute__ ((aligned (32))) double statet[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &stateqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &stateqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statet[j][i] = slave_temperature(statept[swindex[j]][i],stateph[swindex[j]][i],stateqv[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statet+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statet[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_0_info *data = (accum_uv_cell_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = advptu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_1_info *data = (accum_uv_cell_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = advptv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_2_info *data = (accum_uv_cell_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = stateu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_3_info *data = (accum_uv_cell_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_4_info *data = (accum_uv_cell_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = ((advptuu[j][i] + stateu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_5_info *data = (accum_uv_cell_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = ((advptvv[j][i] + statev_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_6_info *data = (accum_uv_cell_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptu0[j][i] = advptuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_7_info *data = (accum_uv_cell_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptv0[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_8_info *data = (accum_uv_cell_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = (advptuu[j][i] + stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_9_info *data = (accum_uv_cell_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = (advptvv[j][i] + statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_10_info *data = (accum_uv_cell_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflx[j][i] = ((advptuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_11_info *data = (accum_uv_cell_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcfly[j][i] = ((advptvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_12_info *data = (accum_uv_cell_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[10][258];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivx[j][i] = (((advptuu[swindex[j]][i] - advptuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advptdivy[j][i] = (((advptvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advptvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_13_info *data = (accum_uv_cell_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_14_info *data = (accum_uv_cell_0_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[8][256];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivy[j][i] = (((statetmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_0_info *data = (calc_mf_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfx_lon[j][i] = (statem_lon[swindex[j]][i] * stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statemfx_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_1_info *data = (calc_mf_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfy_lat[j][i] = (statem_lat[swindex[j]][i] * statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statemfy_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_0_info *data = (accum_mf_cell_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = statemfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_1_info *data = (accum_mf_cell_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = statemfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_2_info *data = (accum_mf_cell_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = ((advptmfx[j][i] + statemfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_3_info *data = (accum_mf_cell_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = ((advptmfy[j][i] + statemfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_4_info *data = (accum_mf_cell_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = (advptmfx[j][i] + statemfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_5_info *data = (accum_mf_cell_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = (advptmfy[j][i] + statemfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_2_info *data = (calc_mf_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  double *_statemfx_lat = data->statemfx_lat;
  __attribute__ ((aligned (32))) double statemfx_lat[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfx_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfx_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfx_lat[j][i] = ((half_tangent_wgt_0[j+jb+oy] * (statemfx_lon[swindex[j]][(i - 1)] + statemfx_lon[swindex[j]][i])) + (half_tangent_wgt_1[j+jb+oy] * (statemfx_lon[swindex[(j + 1)]][(i - 1)] + statemfx_lon[swindex[(j + 1)]][i])));
            stateu_lat[j][i] = (statemfx_lat[j][i] / statem_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statemfx_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &stateu_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_3_info *data = (calc_mf_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  double *_statemfy_lon = data->statemfy_lon;
  __attribute__ ((aligned (32))) double statemfy_lon[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  double *_statev_lon = data->statev_lon;
  __attribute__ ((aligned (32))) double statev_lon[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfy_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfy_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfy_lon[j][i] = ((full_tangent_wgt_0[j+jb+oy] * (statemfy_lat[swindex[(j - 1)]][i] + statemfy_lat[swindex[(j - 1)]][(i + 1)])) + (full_tangent_wgt_1[j+jb+oy] * (statemfy_lat[swindex[j]][i] + statemfy_lat[swindex[j]][(i + 1)])));
            statev_lon[j][i] = (statemfy_lon[j][i] / statem_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statemfy_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_0_info *data = (calc_ke_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = (((((area_lon_west[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2)) + (area_lon_east[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) + (area_lat_north[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2))) + (area_lat_south[j+jb+oy] * pow(statev_lat[swindex[j]][i],2))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_1_info *data = (calc_ke_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  double *_area_lat_east = data->area_lat_east;
  __attribute__ ((aligned (32))) double area_lat_east[hny+2*hy];
  
  double *_area_lat_west = data->area_lat_west;
  __attribute__ ((aligned (32))) double area_lat_west[hny+2*hy];
  
  double *_area_lon_north = data->area_lon_north;
  __attribute__ ((aligned (32))) double area_lon_north[fny+2*hy];
  
  double *_area_lon_south = data->area_lon_south;
  __attribute__ ((aligned (32))) double area_lon_south[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_east+(ghy-hy), &area_lat_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_west+(ghy-hy), &area_lat_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_north+(ghy-hy), &area_lon_north[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_south+(ghy-hy), &area_lon_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = ((((1.0 - 0.5) * ((((((((area_lat_east[j+jb+oy] * pow(statev_lat[swindex[j]][(i - 1)],2)) + (area_lat_west[j+jb+oy] * pow(statev_lat[swindex[j]][i],2))) + (area_lon_north[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(stateu_lon[swindex[(j + 1)]][(i - 1)],2))) / area_vtx[j+jb+oy]) + (((((area_lat_east[j+jb+oy] * pow(statev_lat[swindex[j]][i],2)) + (area_lat_west[j+jb+oy] * pow(statev_lat[swindex[j]][(i + 1)],2))) + (area_lon_north[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(stateu_lon[swindex[(j + 1)]][i],2))) / area_vtx[j+jb+oy])) * area_subcell_1[j+jb+oy]) + (((((((area_lat_east[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][(i - 1)],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(stateu_lon[swindex[(j - 1)]][(i - 1)],2))) + (area_lon_south[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2))) / area_vtx[(j+jb+oy - 1)]) + (((((area_lat_east[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][(i + 1)],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(stateu_lon[swindex[(j - 1)]][i],2))) + (area_lon_south[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) / area_vtx[(j+jb+oy - 1)])) * area_subcell_0[j+jb+oy]))) / area_cell[j+jb+oy]) + (0.5 * stateke[j][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_2_info *data = (calc_ke_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = pow(statev_lat[swindex[j]][i],2);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_3_info *data = (calc_ke_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = (statetmpsum[swindex[j]][i] / 2400);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_0_0_info *data = (calc_vor_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statevor[j][i] = ((((stateu_lon[swindex[j]][i] * de_lon[j+jb+oy]) - (stateu_lon[swindex[(j + 1)]][i] * de_lon[(j+jb+oy + 1)])) + ((statev_lat[swindex[j]][(i + 1)] * de_lat[j+jb+oy]) - (statev_lat[swindex[j]][i] * de_lat[j+jb+oy]))) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_0_1_info *data = (calc_vor_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[8][256];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = (-stateu_lat[swindex[j]][i] * le_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_0_2_info *data = (calc_vor_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[8][256];
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[8][256];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statevor[j][i] = ((statetmpsum[swindex[j]][i] / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_pv_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_pv_0_0_info *data = (calc_pv_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[12][260];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_half_f = data->half_f;
  __attribute__ ((aligned (32))) double half_f[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_f+(ghy-hy), &half_f[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &statevor[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &statem_vtx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &statevor[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &statem_vtx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statepv[j][i] = ((statevor[swindex[j]][i] + half_f[j+jb+oy]) / statem_vtx[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statepv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_0_0_info *data = (interp_pv_upwind_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lon = data->statev_lon;
  __attribute__ ((aligned (32))) double statev_lon[12][260];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_statepv_lon = data->statepv_lon;
  __attribute__ ((aligned (32))) double statepv_lon[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statev_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(statev_lon[swindex[j]][i]) / (sqrt((pow(stateu_lon[swindex[j]][i],2) + pow(statev_lon[swindex[j]][i],2))) + 1e-24));
            statepv_lon[j][i] = ((b * slave_upwind3(sign(1.0,statev_lon[swindex[j]][i]),1,statepv[swindex[(j - 2)]][i],statepv[swindex[(j - 1)]][i],statepv[swindex[j]][i],statepv[swindex[(j + 1)]][i])) + (((1 - b) * 0.5) * (statepv[swindex[(j - 1)]][i] + statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statepv_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_0_1_info *data = (interp_pv_upwind_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[12][260];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_statepv_lat = data->statepv_lat;
  __attribute__ ((aligned (32))) double statepv_lat[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(stateu_lat[swindex[j]][i]) / (sqrt((pow(stateu_lat[swindex[j]][i],2) + pow(statev_lat[swindex[j]][i],2))) + 1e-24));
            statepv_lat[j][i] = ((b * slave_upwind3(sign(1.0,stateu_lat[swindex[j]][i]),1,statepv[swindex[j]][(i - 2)],statepv[swindex[j]][(i - 1)],statepv[swindex[j]][i],statepv[swindex[j]][(i + 1)])) + (((1 - b) * 0.5) * (statepv[swindex[j]][(i - 1)] + statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statepv_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_0_0_info *data = (calc_div_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statediv = data->statediv;
  __attribute__ ((aligned (32))) double statediv[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statediv[j][i] = ((((stateu_lon[swindex[j]][i] * le_lon[j+jb+oy]) - (stateu_lon[swindex[j]][(i - 1)] * le_lon[j+jb+oy])) + ((statev_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (statev_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)]))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_0_1_info *data = (calc_div_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_0_2_info *data = (calc_div_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  double *_statediv = data->statediv;
  __attribute__ ((aligned (32))) double statediv[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statediv[j][i] = (((statetmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_gz_lev_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_gz_lev_0_0_info *data = (calc_gz_lev_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statet = data->statet;
  __attribute__ ((aligned (32))) double statet[bz+2*hz][bx+2*hx];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[bz+2*hz][bx+2*hx];
  
  double *_staticvgzs = data->staticvgzs;
  __attribute__ ((aligned (32))) double staticvgzs[bz+2*hz][bx+2*hx];
  
  double *_stategz_lev = data->stategz_lev;
  __attribute__ ((aligned (32))) double stategz_lev[bz+2*hz][bx+2*hx];
  
  double dgz;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_statet+(k*fnumy*fnumx+jb*fnumx+ib), &statet[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(jb*fnumx+ib), &staticvgzs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_statet+(k*fnumy*fnumx+jb*fnumx+ib), &statet[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(k*fnumy*fnumx+jb*fnumx+ib), &staticvgzs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            dgz = 0.0;
            for (l=k;l<((32 - 1) + 1)+ghz;l+=1){
              dgz = (dgz + ((287.04 * statet[swindex[l]][i]) * log((stateph_lev[swindex[(l + 1)]][i] / stateph_lev[swindex[l]][i]))));
            }
            stategz_lev[k][i] = (staticvgzs[swindex[0]][i] + dgz);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stategz_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void copy_old_m_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_0_0_info *data = (copy_old_m_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_advmold_m = data->advmold_m;
  __attribute__ ((aligned (32))) double advmold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmold_m[j][i] = statem[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void copy_old_m_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_0_1_info *data = (copy_old_m_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_advptold_m = data->advptold_m;
  __attribute__ ((aligned (32))) double advptold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptold_m[j][i] = statem[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}


void accum_uv_cell_0_45(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_45_info *data = (accum_uv_cell_0_45_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = advptu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_46(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_46_info *data = (accum_uv_cell_0_46_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = advptv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_47(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_47_info *data = (accum_uv_cell_0_47_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = star_stateu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_48(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_48_info *data = (accum_uv_cell_0_48_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = star_statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_49(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_49_info *data = (accum_uv_cell_0_49_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = ((advptuu[j][i] + star_stateu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_50(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_50_info *data = (accum_uv_cell_0_50_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = ((advptvv[j][i] + star_statev_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_51(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_51_info *data = (accum_uv_cell_0_51_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptu0[j][i] = advptuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_52(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_52_info *data = (accum_uv_cell_0_52_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptv0[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_53(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_53_info *data = (accum_uv_cell_0_53_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = (advptuu[j][i] + star_stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_54(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_54_info *data = (accum_uv_cell_0_54_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = (advptvv[j][i] + star_statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_55(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_55_info *data = (accum_uv_cell_0_55_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflx[j][i] = ((advptuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_56(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_56_info *data = (accum_uv_cell_0_56_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcfly[j][i] = ((advptvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_57(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_57_info *data = (accum_uv_cell_0_57_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[10][258];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivx[j][i] = (((advptuu[swindex[j]][i] - advptuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advptdivy[j][i] = (((advptvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advptvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_58(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_58_info *data = (accum_uv_cell_0_58_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_59(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_59_info *data = (accum_uv_cell_0_59_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivy[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_12_info *data = (calc_mf_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfx_lon[j][i] = (star_statem_lon[swindex[j]][i] * star_stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statemfx_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_13_info *data = (calc_mf_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfy_lat[j][i] = (star_statem_lat[swindex[j]][i] * star_statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statemfy_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_18_info *data = (accum_mf_cell_0_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = star_statemfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_19_info *data = (accum_mf_cell_0_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = star_statemfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_20_info *data = (accum_mf_cell_0_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = ((advptmfx[j][i] + star_statemfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_21_info *data = (accum_mf_cell_0_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = ((advptmfy[j][i] + star_statemfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_22_info *data = (accum_mf_cell_0_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = (advptmfx[j][i] + star_statemfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_23_info *data = (accum_mf_cell_0_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = (advptmfy[j][i] + star_statemfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_14_info *data = (calc_mf_0_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_star_statemfx_lat = data->star_statemfx_lat;
  __attribute__ ((aligned (32))) double star_statemfx_lat[10][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[10][258];
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfx_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfx_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfx_lat[j][i] = ((half_tangent_wgt_0[j+jb+oy] * (star_statemfx_lon[swindex[j]][(i - 1)] + star_statemfx_lon[swindex[j]][i])) + (half_tangent_wgt_1[j+jb+oy] * (star_statemfx_lon[swindex[(j + 1)]][(i - 1)] + star_statemfx_lon[swindex[(j + 1)]][i])));
            star_stateu_lat[j][i] = (star_statemfx_lat[j][i] / star_statem_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statemfx_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateu_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_0_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_0_15_info *data = (calc_mf_0_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statemfy_lon = data->star_statemfy_lon;
  __attribute__ ((aligned (32))) double star_statemfy_lon[10][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[10][258];
  
  double *_star_statev_lon = data->star_statev_lon;
  __attribute__ ((aligned (32))) double star_statev_lon[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfy_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfy_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfy_lon[j][i] = ((full_tangent_wgt_0[j+jb+oy] * (star_statemfy_lat[swindex[(j - 1)]][i] + star_statemfy_lat[swindex[(j - 1)]][(i + 1)])) + (full_tangent_wgt_1[j+jb+oy] * (star_statemfy_lat[swindex[j]][i] + star_statemfy_lat[swindex[j]][(i + 1)])));
            star_statev_lon[j][i] = (star_statemfy_lon[j][i] / star_statem_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statemfy_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_12_info *data = (calc_ke_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = (((((area_lon_west[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2)) + (area_lon_east[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) + (area_lat_north[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2))) + (area_lat_south[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_13_info *data = (calc_ke_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_area_lat_east = data->area_lat_east;
  __attribute__ ((aligned (32))) double area_lat_east[hny+2*hy];
  
  double *_area_lat_west = data->area_lat_west;
  __attribute__ ((aligned (32))) double area_lat_west[hny+2*hy];
  
  double *_area_lon_north = data->area_lon_north;
  __attribute__ ((aligned (32))) double area_lon_north[fny+2*hy];
  
  double *_area_lon_south = data->area_lon_south;
  __attribute__ ((aligned (32))) double area_lon_south[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_east+(ghy-hy), &area_lat_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_west+(ghy-hy), &area_lat_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_north+(ghy-hy), &area_lon_north[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_south+(ghy-hy), &area_lon_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = ((((1.0 - 0.5) * ((((((((area_lat_east[j+jb+oy] * pow(star_statev_lat[swindex[j]][(i - 1)],2)) + (area_lat_west[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2))) + (area_lon_north[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(star_stateu_lon[swindex[(j + 1)]][(i - 1)],2))) / area_vtx[j+jb+oy]) + (((((area_lat_east[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2)) + (area_lat_west[j+jb+oy] * pow(star_statev_lat[swindex[j]][(i + 1)],2))) + (area_lon_north[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(star_stateu_lon[swindex[(j + 1)]][i],2))) / area_vtx[j+jb+oy])) * area_subcell_1[j+jb+oy]) + (((((((area_lat_east[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][(i - 1)],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(star_stateu_lon[swindex[(j - 1)]][(i - 1)],2))) + (area_lon_south[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2))) / area_vtx[(j+jb+oy - 1)]) + (((((area_lat_east[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][(i + 1)],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(star_stateu_lon[swindex[(j - 1)]][i],2))) + (area_lon_south[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) / area_vtx[(j+jb+oy - 1)])) * area_subcell_0[j+jb+oy]))) / area_cell[j+jb+oy]) + (0.5 * star_stateke[j][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_14_info *data = (calc_ke_0_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = pow(star_statev_lat[swindex[j]][i],2);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_0_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_0_15_info *data = (calc_ke_0_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = (star_statetmpsum[swindex[j]][i] / 2400);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_0_9_info *data = (calc_div_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statediv = data->star_statediv;
  __attribute__ ((aligned (32))) double star_statediv[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statediv[j][i] = ((((star_stateu_lon[swindex[j]][i] * le_lon[j+jb+oy]) - (star_stateu_lon[swindex[j]][(i - 1)] * le_lon[j+jb+oy])) + ((star_statev_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_statev_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)]))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_0_10_info *data = (calc_div_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = star_statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_0_11_info *data = (calc_div_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  double *_star_statediv = data->star_statediv;
  __attribute__ ((aligned (32))) double star_statediv[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statediv[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_0_9_info *data = (calc_vor_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statevor[j][i] = ((((star_stateu_lon[swindex[j]][i] * de_lon[j+jb+oy]) - (star_stateu_lon[swindex[(j + 1)]][i] * de_lon[(j+jb+oy + 1)])) + ((star_statev_lat[swindex[j]][(i + 1)] * de_lat[j+jb+oy]) - (star_statev_lat[swindex[j]][i] * de_lat[j+jb+oy]))) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_0_10_info *data = (calc_vor_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[8][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = (-star_stateu_lat[swindex[j]][i] * le_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_0_11_info *data = (calc_vor_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[8][256];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statevor[j][i] = ((star_statetmpsum[swindex[j]][i] / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_pv_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_pv_0_3_info *data = (calc_pv_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[12][260];
  
  double *_star_statem_vtx = data->star_statem_vtx;
  __attribute__ ((aligned (32))) double star_statem_vtx[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_half_f = data->half_f;
  __attribute__ ((aligned (32))) double half_f[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_f+(ghy-hy), &half_f[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &star_statevor[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_vtx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &star_statevor[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_vtx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statepv[j][i] = ((star_statevor[swindex[j]][i] + half_f[j+jb+oy]) / star_statem_vtx[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statepv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_0_6_info *data = (interp_pv_upwind_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lon = data->star_statev_lon;
  __attribute__ ((aligned (32))) double star_statev_lon[12][260];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statev_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(star_statev_lon[swindex[j]][i]) / (sqrt((pow(star_stateu_lon[swindex[j]][i],2) + pow(star_statev_lon[swindex[j]][i],2))) + 1e-24));
            star_statepv_lon[j][i] = ((b * slave_upwind3(sign(1.0,star_statev_lon[swindex[j]][i]),1,star_statepv[swindex[(j - 2)]][i],star_statepv[swindex[(j - 1)]][i],star_statepv[swindex[j]][i],star_statepv[swindex[(j + 1)]][i])) + (((1 - b) * 0.5) * (star_statepv[swindex[(j - 1)]][i] + star_statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statepv_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_0_7_info *data = (interp_pv_upwind_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[12][260];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(star_stateu_lat[swindex[j]][i]) / (sqrt((pow(star_stateu_lat[swindex[j]][i],2) + pow(star_statev_lat[swindex[j]][i],2))) + 1e-24));
            star_statepv_lat[j][i] = ((b * slave_upwind3(sign(1.0,star_stateu_lat[swindex[j]][i]),1,star_statepv[swindex[j]][(i - 2)],star_statepv[swindex[j]][(i - 1)],star_statepv[swindex[j]][i],star_statepv[swindex[j]][(i + 1)])) + (((1 - b) * 0.5) * (star_statepv[swindex[j]][(i - 1)] + star_statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statepv_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_0_8_info *data = (calc_grad_mf_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_tend1dmfdlon = data->tend1dmfdlon;
  __attribute__ ((aligned (32))) double tend1dmfdlon[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlon[j][i] = (((star_statemfx_lon[swindex[j]][i] - star_statemfx_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_0_9_info *data = (calc_grad_mf_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlat[j][i] = (((star_statemfy_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_statemfy_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_0_10_info *data = (calc_grad_mf_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = star_statemfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_0_11_info *data = (calc_grad_mf_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlat[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_we_lev_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_we_lev_0_2_info *data = (calc_we_lev_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dmfdlon = data->tend1dmfdlon;
  __attribute__ ((aligned (32))) double tend1dmfdlon[bz+2*hz][bx+2*hx];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[bz+2*hz][bx+2*hx];
  
  double *_tend1dphs = data->tend1dphs;
  __attribute__ ((aligned (32))) double tend1dphs[bz+2*hz][bx+2*hx];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[bz+2*hz][bx+2*hx];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  double mfs;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_tend1dmfdlon+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dmfdlat+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dphs+(jb*fnumx+ib), &tend1dphs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_tend1dmfdlon+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dmfdlat+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dphs+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dphs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            mfs = 0.0;
            for (l=0+ghz;l<((k - 1) + 1);l+=1){
              mfs = ((mfs + tend1dmfdlon[swindex[l]][i]) + tend1dmfdlat[swindex[l]][i]);
            }
            star_statewe_lev[k][i] = (-slave_hybrid_coord_calc_dphdt_lev(hybi[k+kb+oz],tend1dphs[swindex[0]][i]) - mfs);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_statewe_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_statewe_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_10_info *data = (accum_we_lev_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe0 = data->advptwe0;
  __attribute__ ((aligned (32))) double advptwe0[8][256];
  
  double *_advptm0 = data->advptm0;
  __attribute__ ((aligned (32))) double advptm0[8][256];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[8][256];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe0[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib), &advptm0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe0[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib), &advptm0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = advptwe0[j][i];
            advptmm[j][i] = advptm0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_11_info *data = (accum_we_lev_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = star_statewe_lev[swindex[j]][i];
            advptmm[j][i] = star_statem_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_12_info *data = (accum_we_lev_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  double *_advptwe0 = data->advptwe0;
  __attribute__ ((aligned (32))) double advptwe0[10][258];
  
  double *_advptm0 = data->advptm0;
  __attribute__ ((aligned (32))) double advptm0[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = ((advptwe[j][i] + star_statewe_lev[swindex[j]][i]) / ((nstep) + 1));
            advptmm[j][i] = ((advptmm[j][i] + star_statem_lev[swindex[j]][i]) / ((nstep) + 1));
            advptwe0[j][i] = star_statewe_lev[swindex[j]][i];
            advptm0[j][i] = star_statem_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptm0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_13_info *data = (accum_we_lev_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = (advptwe[j][i] + star_statewe_lev[swindex[j]][i]);
            advptmm[j][i] = (advptmm[j][i] + star_statem_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_14_info *data = (accum_we_lev_0_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[8][256];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[8][256];
  
  double *_advptcflz = data->advptcflz;
  __attribute__ ((aligned (32))) double advptcflz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflz[j][i] = ((advptwe[swindex[j]][i] / advptmm[swindex[j]][i]) * dt);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_lev_edge_to_lev_lon_edge_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_lev_edge_to_lev_lon_edge_0_2_info *data = (interp_lev_edge_to_lev_lon_edge_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lon = data->area_lon;
  __attribute__ ((aligned (32))) double area_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon+(ghy-hy), &area_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statewe_lev_lon[j][i] = (((area_lon_west[j+jb+oy] * star_statewe_lev[swindex[j]][i]) + (area_lon_east[j+jb+oy] * star_statewe_lev[swindex[j]][(i + 1)])) / area_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statewe_lev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statewe_lev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_lev_edge_to_lev_lat_edge_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_lev_edge_to_lev_lat_edge_0_2_info *data = (interp_lev_edge_to_lev_lat_edge_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[10][258];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_lat = data->area_lat;
  __attribute__ ((aligned (32))) double area_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat+(ghy-hy), &area_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statewe_lev_lat[j][i] = (((area_lat_north[j+jb+oy] * star_statewe_lev[swindex[(j + 1)]][i]) + (area_lat_south[j+jb+oy] * star_statewe_lev[swindex[j]][i])) / area_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statewe_lev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statewe_lev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_0_8_info *data = (calc_wedudlev_wedvdlev_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[6][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[6][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[6][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedudlev[k][i] = ((((star_statewe_lev_lon[swindex[(k + 1)]][i] * (star_stateu_lon[swindex[(k + 1)]][i] - star_stateu_lon[swindex[k]][i])) + (star_statewe_lev_lon[swindex[k]][i] * (star_stateu_lon[swindex[k]][i] - star_stateu_lon[swindex[(k - 1)]][i]))) / star_statem_lon[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedudlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1wedudlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_0_9_info *data = (calc_wedudlev_wedvdlev_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[6][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[6][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[6][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedudlev[k][i] = (((star_statewe_lev_lon[swindex[k]][i] * (star_stateu_lon[swindex[k]][i] - star_stateu_lon[swindex[(k - 1)]][i])) / star_statem_lon[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedudlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1wedudlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_0_10_info *data = (calc_wedudlev_wedvdlev_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[6][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[6][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[6][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedvdlev[k][i] = ((((star_statewe_lev_lat[swindex[(k + 1)]][i] * (star_statev_lat[swindex[(k + 1)]][i] - star_statev_lat[swindex[k]][i])) + (star_statewe_lev_lat[swindex[k]][i] * (star_statev_lat[swindex[k]][i] - star_statev_lat[swindex[(k - 1)]][i]))) / star_statem_lat[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedvdlev+(k*hnumy*hnumx+jb*hnumx+ib+hx), &tend1wedvdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_0_11_info *data = (calc_wedudlev_wedvdlev_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[6][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[6][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[6][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedvdlev[k][i] = (((star_statewe_lev_lat[swindex[k]][i] * (star_statev_lat[swindex[k]][i] - star_statev_lat[swindex[(k - 1)]][i])) / star_statem_lat[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedvdlev+(k*hnumy*hnumx+jb*hnumx+ib+hx), &tend1wedvdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_0_6_info *data = (hflx_ppm_inner_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[12][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[12][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[12][260];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[12][260];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[12][260];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(star_statept[swindex[j]][(i - 2)],star_statept[swindex[j]][(i - 1)],star_statept[swindex[j]][i],star_statept[swindex[j]][(i + 1)],star_statept[swindex[j]][(i + 2)]);
            advptqlx[j][i] = buf.x;
            advptdqx[j][i] = buf.y;
            advptq6x[j][i] = buf.z;
            buf = slave_ppm(star_statept[swindex[(j - 2)]][i],star_statept[swindex[(j - 1)]][i],star_statept[swindex[j]][i],star_statept[swindex[(j + 1)]][i],star_statept[swindex[(j + 2)]][i]);
            advptqly[j][i] = buf.x;
            advptdqy[j][i] = buf.y;
            advptq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_0_7_info *data = (hflx_ppm_inner_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[by+2*hy][bx+2*hx];
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[by+2*hy][bx+2*hx];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[by+2*hy][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[by+2*hy][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[by+2*hy][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[by+2*hy][bx+2*hx];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflx[swindex[j]][i]);
            cf = (advptcflx[swindex[j]][i] - ci);
            if ((advptcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + star_statept[swindex[j]][l]);
              }
              star_stateptf_lon[j][i] = ((advptuu[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advptdqx[swindex[j]][(i - ci)]) * ds2)) + (advptq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
            }
            else
            {
              if ((advptcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + star_statept[swindex[j]][l]);
                }
                star_stateptf_lon[j][i] = ((-advptuu[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advptdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advptq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateptf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_0_8_info *data = (hflx_ppm_inner_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[10][256];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[10][256];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[10][256];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advptcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advptcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              star_stateptf_lat[j][i] = ((advptvv[swindex[j]][i] * (((advptqly[swindex[j]][i] * ds1) + ((0.5 * advptdqy[swindex[j]][i]) * ds2)) + (advptq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
            }
            else
            {
              if ((advptcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advptcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                star_stateptf_lat[j][i] = ((-advptvv[swindex[j]][i] * (((advptqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advptdqy[swindex[(j + 1)]][i]) * ds2)) + (advptq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateptf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_0_6_info *data = (ffsl_calc_tracer_hflx_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[12][260];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[12][260];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[12][260];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptqx[j][i] = (star_statept[swindex[j]][i] - ((0.5 * ((((star_stateptf_lon[swindex[j]][i] - star_stateptf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]) - (advptdivx[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
            advptqy[j][i] = (star_statept[swindex[j]][i] - ((0.5 * ((((star_stateptf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_stateptf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) - (advptdivy[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_0_7_info *data = (ffsl_calc_tracer_hflx_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = star_stateptf_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_0_8_info *data = (ffsl_calc_tracer_hflx_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[12][260];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptqx[j][i] = star_statept[swindex[j]][i];
            advptqy[j][i] = (star_statept[swindex[j]][i] + ((0.5 * ((((star_statetmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]) - (advptdivy[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_0_6_info *data = (hflx_ppm_outer_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[12][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[12][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[12][260];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[12][260];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[12][260];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(advptqy[swindex[j]][(i - 2)],advptqy[swindex[j]][(i - 1)],advptqy[swindex[j]][i],advptqy[swindex[j]][(i + 1)],advptqy[swindex[j]][(i + 2)]);
            advptqlx[j][i] = buf.x;
            advptdqx[j][i] = buf.y;
            advptq6x[j][i] = buf.z;
            buf = slave_ppm(advptqx[swindex[(j - 2)]][i],advptqx[swindex[(j - 1)]][i],advptqx[swindex[j]][i],advptqx[swindex[(j + 1)]][i],advptqx[swindex[(j + 2)]][i]);
            advptqly[j][i] = buf.x;
            advptdqy[j][i] = buf.y;
            advptq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_0_7_info *data = (hflx_ppm_outer_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[by+2*hy][bx+2*hx];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[by+2*hy][bx+2*hx];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[by+2*hy][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[by+2*hy][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[by+2*hy][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[by+2*hy][bx+2*hx];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflx[swindex[j]][i]);
            cf = (advptcflx[swindex[j]][i] - ci);
            if ((advptcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + advptqy[swindex[j]][l]);
              }
              star_stateptf_lon[j][i] = ((advptmfx[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advptdqx[swindex[j]][(i - ci)]) * ds2)) + (advptq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
            }
            else
            {
              if ((advptcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + advptqy[swindex[j]][l]);
                }
                star_stateptf_lon[j][i] = ((-advptmfx[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advptdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advptq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateptf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_0_8_info *data = (hflx_ppm_outer_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][256];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[10][256];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[10][256];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[10][256];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advptcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advptcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              star_stateptf_lat[j][i] = ((advptmfy[swindex[j]][i] * (((advptqly[swindex[j]][i] * ds1) + ((0.5 * advptdqy[swindex[j]][i]) * ds2)) + (advptq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
            }
            else
            {
              if ((advptcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advptcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                star_stateptf_lat[j][i] = ((-advptmfy[swindex[j]][i] * (((advptqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advptdqy[swindex[(j + 1)]][i]) * ds2)) + (advptq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateptf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_0_12_info *data = (calc_grad_ptf_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[8][258];
  
  double *_tend1dptfdlon = data->tend1dptfdlon;
  __attribute__ ((aligned (32))) double tend1dptfdlon[8][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlon[j][i] = (((star_stateptf_lon[swindex[j]][i] - star_stateptf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_0_13_info *data = (calc_grad_ptf_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[10][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlat[j][i] = (((star_stateptf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_stateptf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_0_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_0_14_info *data = (calc_grad_ptf_0_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = star_stateptf_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_0_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_0_15_info *data = (calc_grad_ptf_0_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlat[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_0_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_0_16_info *data = (calc_grad_ptf_0_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[8][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            star_statept[k][i] = ((2 * star_statept[(k - 1)][i]) - star_statept[(k - 2)][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_statept[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_0_4_info *data = (vflx_ppm_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[8][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[8][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[8][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[8][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(star_statept[swindex[(k - 2)]][i],star_statept[swindex[(k - 1)]][i],star_statept[swindex[k]][i],star_statept[swindex[(k + 1)]][i],star_statept[swindex[(k + 2)]][i]);
            advptqlx[k][i] = buf.x;
            advptdqx[k][i] = buf.y;
            advptq6x[k][i] = buf.z;
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptqlx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptdqx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptq6x[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_0_5_info *data = (vflx_ppm_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflz = data->advptcflz;
  __attribute__ ((aligned (32))) double advptcflz[bz+2*hz][bx+2*hx];
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[bz+2*hz][bx+2*hx];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[bz+2*hz][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[bz+2*hz][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[bz+2*hz][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[bz+2*hz][bx+2*hx];
  
  double *_star_stateptf_lev = data->star_stateptf_lev;
  __attribute__ ((aligned (32))) double star_stateptf_lev[bz+2*hz][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_advptcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advptcflz[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptwe+(k*fnumy*fnumx+jb*fnumx+ib), &advptwe[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advptqlx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advptdqx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advptq6x[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_advptcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advptcflz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptwe+(k*fnumy*fnumx+jb*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflz[swindex[k]][i]);
            cf = (advptcflz[swindex[k]][i] - ci);
            if ((advptcflz[swindex[k]][i] > 0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=(k - ci);l<((k - 1) + 1);l+=1){
                cursum = (cursum + star_statept[swindex[l]][i]);
              }
              star_stateptf_lev[k][i] = ((advptwe[swindex[k]][i] * (((cursum + (advptqlx[swindex[((k - ci) - 1)]][i] * ds1)) + ((0.5 * advptdqx[swindex[((k - ci) - 1)]][i]) * ds2)) + (advptq6x[swindex[((k - ci) - 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflz[swindex[k]][i]);
            }
            else
            {
              if ((advptcflz[swindex[k]][i] < 0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                for (l=k;l<(((k - ci) - 1) + 1);l+=1){
                  cursum = (cursum + star_statept[swindex[l]][i]);
                }
                star_stateptf_lev[k][i] = ((-advptwe[swindex[k]][i] * (((cursum + (advptqlx[swindex[(k - ci)]][i] * ds1)) + ((0.5 * advptdqx[swindex[(k - ci)]][i]) * ds2)) + (advptq6x[swindex[(k - ci)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflz[swindex[k]][i]);
              }
              else
              {
                star_stateptf_lev[k][i] = 0.0;
              }
            }
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_stateptf_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_0_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_0_17_info *data = (calc_grad_ptf_0_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lev = data->star_stateptf_lev;
  __attribute__ ((aligned (32))) double star_stateptf_lev[6][256];
  
  double *_tend1dptfdlev = data->tend1dptfdlev;
  __attribute__ ((aligned (32))) double tend1dptfdlev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateptf_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateptf_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlev[k][i] = (star_stateptf_lev[swindex[(k + 1)]][i] - star_stateptf_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1dptfdlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1dptfdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_coriolis_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_coriolis_0_4_info *data = (calc_coriolis_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[10][258];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[10][258];
  
  double *_tend1qhu = data->tend1qhu;
  __attribute__ ((aligned (32))) double tend1qhu[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1qhu[j][i] = (((half_tangent_wgt_0[j+jb+oy] * ((star_statemfx_lon[swindex[j]][(i - 1)] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[j]][(i - 1)])) + (star_statemfx_lon[swindex[j]][i] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[j]][i])))) + (half_tangent_wgt_1[j+jb+oy] * ((star_statemfx_lon[swindex[(j + 1)]][(i - 1)] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[(j + 1)]][(i - 1)])) + (star_statemfx_lon[swindex[(j + 1)]][i] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[(j + 1)]][i]))))) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1qhu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_coriolis_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_coriolis_0_5_info *data = (calc_coriolis_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[10][258];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[10][258];
  
  double *_tend1qhv = data->tend1qhv;
  __attribute__ ((aligned (32))) double tend1qhv[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1qhv[j][i] = (((full_tangent_wgt_0[j+jb+oy] * ((star_statemfy_lat[swindex[(j - 1)]][i] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[(j - 1)]][i])) + (star_statemfy_lat[swindex[(j - 1)]][(i + 1)] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[(j - 1)]][(i + 1)])))) + (full_tangent_wgt_1[j+jb+oy] * ((star_statemfy_lat[swindex[j]][i] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[j]][i])) + (star_statemfy_lat[swindex[j]][(i + 1)] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[j]][(i + 1)]))))) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1qhv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ke_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ke_0_4_info *data = (calc_grad_ke_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_tend1dkedlon = data->tend1dkedlon;
  __attribute__ ((aligned (32))) double tend1dkedlon[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dkedlon[j][i] = ((star_stateke[swindex[j]][(i + 1)] - star_stateke[swindex[j]][i]) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dkedlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ke_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ke_0_5_info *data = (calc_grad_ke_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_tend1dkedlat = data->tend1dkedlat;
  __attribute__ ((aligned (32))) double tend1dkedlat[10][258];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dkedlat[j][i] = ((star_stateke[swindex[(j + 1)]][i] - star_stateke[swindex[j]][i]) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1dkedlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_0_6_info *data = (calc_tend_forward_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1qhv = data->tend1qhv;
  __attribute__ ((aligned (32))) double tend1qhv[10][258];
  
  double *_tend1dkedlon = data->tend1dkedlon;
  __attribute__ ((aligned (32))) double tend1dkedlon[10][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[10][258];
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib), &tend1qhv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dkedlon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedudlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1wedudlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib), &tend1qhv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dkedlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedudlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1wedudlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1du[j][i] = ((tend1qhv[swindex[j]][i] - tend1dkedlon[swindex[j]][i]) - tend1wedudlev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1du[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_0_7_info *data = (calc_tend_forward_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1qhu = data->tend1qhu;
  __attribute__ ((aligned (32))) double tend1qhu[10][258];
  
  double *_tend1dkedlat = data->tend1dkedlat;
  __attribute__ ((aligned (32))) double tend1dkedlat[10][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[10][258];
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib), &tend1qhu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dkedlat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedvdlev+(kb*hnumy*hnumx+j*hnumx+ib), &tend1wedvdlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib), &tend1qhu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dkedlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedvdlev+(kb*hnumy*hnumx+j*hnumx+ib), &tend1wedvdlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dv[j][i] = ((-tend1qhu[swindex[j]][i] - tend1dkedlat[swindex[j]][i]) - tend1wedvdlev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1dv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_0_8_info *data = (calc_tend_forward_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dptfdlon = data->tend1dptfdlon;
  __attribute__ ((aligned (32))) double tend1dptfdlon[10][258];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[10][258];
  
  double *_tend1dptfdlev = data->tend1dptfdlev;
  __attribute__ ((aligned (32))) double tend1dptfdlev[10][258];
  
  double *_tend1dpt = data->tend1dpt;
  __attribute__ ((aligned (32))) double tend1dpt[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dpt[j][i] = ((-tend1dptfdlon[j][i] - tend1dptfdlat[j][i]) - tend1dptfdlev[j][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dpt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_15_info *data = (calc_ph_0_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statephs = data->new_statephs;
  __attribute__ ((aligned (32))) double new_statephs[10][258];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],new_statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_16_info *data = (calc_ph_0_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_exn_lev[j][i] = pow(new_stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_17_info *data = (calc_ph_0_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph[k][i] = (0.5 * (new_stateph_lev[k][i] + new_stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_36(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_36_info *data = (calc_m_0_36_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_37(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_37_info *data = (calc_m_0_37_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_38(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_38_info *data = (calc_m_0_38_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_39(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_39_info *data = (calc_m_0_39_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_0_9_info *data = (averageCellToLonEdge_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_0_9_info *data = (averageCellToLatEdge_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_0_9_info *data = (interpCellToVtx_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_16_info *data = (update_state_0_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statept = data->old_statept;
  __attribute__ ((aligned (32))) double old_statept[12][260];
  
  double *_old_statem = data->old_statem;
  __attribute__ ((aligned (32))) double old_statem[12][260];
  
  double *_tend1dpt = data->tend1dpt;
  __attribute__ ((aligned (32))) double tend1dpt[12][260];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[12][260];
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dpt[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dpt[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statept[j][i] = (((old_statept[swindex[j]][i] * old_statem[swindex[j]][i]) + (dt * tend1dpt[swindex[j]][i])) / new_statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_17_info *data = (update_state_0_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stategz = data->old_stategz;
  __attribute__ ((aligned (32))) double old_stategz[8][256];
  
  double *_tend1dgz = data->tend1dgz;
  __attribute__ ((aligned (32))) double tend1dgz[8][256];
  
  double *_new_stategz = data->new_stategz;
  __attribute__ ((aligned (32))) double new_stategz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dgz[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dgz[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stategz[j][i] = (old_stategz[swindex[j]][i] + (dt * tend1dgz[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stategz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stategz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_40(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_40_info *data = (calc_m_0_40_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_41(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_41_info *data = (calc_m_0_41_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_42(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_42_info *data = (calc_m_0_42_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_43(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_43_info *data = (calc_m_0_43_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_0_10_info *data = (averageCellToLonEdge_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_0_10_info *data = (averageCellToLatEdge_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_0_10_info *data = (interpCellToVtx_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_18_info *data = (update_state_0_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stateu_lon = data->old_stateu_lon;
  __attribute__ ((aligned (32))) double old_stateu_lon[10][258];
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  double *_new_stateu_lon = data->new_stateu_lon;
  __attribute__ ((aligned (32))) double new_stateu_lon[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateu_lon[j][i] = (old_stateu_lon[swindex[j]][i] + (dt * tend1du[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_19_info *data = (update_state_0_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statev_lat = data->old_statev_lat;
  __attribute__ ((aligned (32))) double old_statev_lat[10][258];
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  double *_new_statev_lat = data->new_statev_lat;
  __attribute__ ((aligned (32))) double new_statev_lat[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statev_lat[j][i] = (old_statev_lat[swindex[j]][i] + (dt * tend1dv[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_t_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_t_0_3_info *data = (calc_t_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[12][260];
  
  double *_new_stateqv = data->new_stateqv;
  __attribute__ ((aligned (32))) double new_stateqv[12][260];
  
  double *_new_statet = data->new_statet;
  __attribute__ ((aligned (32))) double new_statet[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib), &new_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib), &new_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statet[j][i] = slave_temperature(new_statept[swindex[j]][i],new_stateph[swindex[j]][i],new_stateqv[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statet+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statet[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_gz_lev_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_gz_lev_0_3_info *data = (calc_gz_lev_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statet = data->new_statet;
  __attribute__ ((aligned (32))) double new_statet[bz+2*hz][bx+2*hx];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[bz+2*hz][bx+2*hx];
  
  double *_staticvgzs = data->staticvgzs;
  __attribute__ ((aligned (32))) double staticvgzs[bz+2*hz][bx+2*hx];
  
  double *_new_stategz_lev = data->new_stategz_lev;
  __attribute__ ((aligned (32))) double new_stategz_lev[bz+2*hz][bx+2*hx];
  
  double dgz;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_statet+(k*fnumy*fnumx+jb*fnumx+ib), &new_statet[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(jb*fnumx+ib), &staticvgzs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_statet+(k*fnumy*fnumx+jb*fnumx+ib), &new_statet[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(k*fnumy*fnumx+jb*fnumx+ib), &staticvgzs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            dgz = 0.0;
            for (l=k;l<((32 - 1) + 1)+ghz;l+=1){
              dgz = (dgz + ((287.04 * new_statet[swindex[l]][i]) * log((new_stateph_lev[swindex[(l + 1)]][i] / new_stateph_lev[swindex[l]][i]))));
            }
            new_stategz_lev[k][i] = (staticvgzs[swindex[0]][i] + dgz);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stategz_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void pgf_lin97_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  pgf_lin97_0_2_info *data = (pgf_lin97_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateqm = data->new_stateqm;
  __attribute__ ((aligned (32))) double new_stateqm[6][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[6][258];
  
  double *_new_stategz_lev = data->new_stategz_lev;
  __attribute__ ((aligned (32))) double new_stategz_lev[6][258];
  
  double *_tend2pgf_lon = data->tend2pgf_lon;
  __attribute__ ((aligned (32))) double tend2pgf_lon[6][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double tl;
  double dph1;
  double dph2;
  double dgz1;
  double dgz2;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateqm+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateqm[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_exn_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_exn_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stategz_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateqm+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateqm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_exn_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_exn_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stategz_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tl = (1 + (0.5 * (new_stateqm[swindex[k]][i] + new_stateqm[swindex[k]][(i + 1)])));
            dph1 = (new_stateph_exn_lev[swindex[(k + 1)]][(i + 1)] - new_stateph_exn_lev[swindex[k]][i]);
            dph2 = (new_stateph_exn_lev[swindex[(k + 1)]][i] - new_stateph_exn_lev[swindex[k]][(i + 1)]);
            dgz1 = (new_stategz_lev[swindex[(k + 1)]][i] - new_stategz_lev[swindex[k]][(i + 1)]);
            dgz2 = (new_stategz_lev[swindex[k]][i] - new_stategz_lev[swindex[(k + 1)]][(i + 1)]);
            tend2pgf_lon[k][i] = (((-((dph1 * dgz1) + (dph2 * dgz2)) / de_lon[jb+oy]) / (dph1 + dph2)) / tl);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend2pgf_lon+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend2pgf_lon[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_backward_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_backward_0_4_info *data = (calc_tend_backward_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  double *_tend2pgf_lon = data->tend2pgf_lon;
  __attribute__ ((aligned (32))) double tend2pgf_lon[10][258];
  
  double *_tend2du = data->tend2du;
  __attribute__ ((aligned (32))) double tend2du[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &tend2pgf_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &tend2pgf_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend2du[j][i] = (tend1du[swindex[j]][i] - tend2pgf_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend2du[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_backward_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_backward_0_5_info *data = (calc_tend_backward_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  double *_tend2pgf_lat = data->tend2pgf_lat;
  __attribute__ ((aligned (32))) double tend2pgf_lat[10][258];
  
  double *_tend2dv = data->tend2dv;
  __attribute__ ((aligned (32))) double tend2dv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &tend2pgf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &tend2pgf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend2dv[j][i] = (tend1dv[swindex[j]][i] - tend2pgf_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend2dv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_18_info *data = (calc_ph_0_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statephs = data->new_statephs;
  __attribute__ ((aligned (32))) double new_statephs[10][258];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],new_statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_19_info *data = (calc_ph_0_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_exn_lev[j][i] = pow(new_stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_20_info *data = (calc_ph_0_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph[k][i] = (0.5 * (new_stateph_lev[k][i] + new_stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_44(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_44_info *data = (calc_m_0_44_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_45(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_45_info *data = (calc_m_0_45_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_46(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_46_info *data = (calc_m_0_46_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_47(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_47_info *data = (calc_m_0_47_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_0_11_info *data = (averageCellToLonEdge_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_0_11_info *data = (averageCellToLatEdge_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_0_11_info *data = (interpCellToVtx_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_20_info *data = (update_state_0_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statept = data->old_statept;
  __attribute__ ((aligned (32))) double old_statept[12][260];
  
  double *_old_statem = data->old_statem;
  __attribute__ ((aligned (32))) double old_statem[12][260];
  
  double *_tend2dpt = data->tend2dpt;
  __attribute__ ((aligned (32))) double tend2dpt[12][260];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[12][260];
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dpt[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dpt[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statept[j][i] = (((old_statept[swindex[j]][i] * old_statem[swindex[j]][i]) + (dt * tend2dpt[swindex[j]][i])) / new_statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_21_info *data = (update_state_0_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stategz = data->old_stategz;
  __attribute__ ((aligned (32))) double old_stategz[8][256];
  
  double *_tend2dgz = data->tend2dgz;
  __attribute__ ((aligned (32))) double tend2dgz[8][256];
  
  double *_new_stategz = data->new_stategz;
  __attribute__ ((aligned (32))) double new_stategz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dgz[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dgz[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stategz[j][i] = (old_stategz[swindex[j]][i] + (dt * tend2dgz[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stategz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stategz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_48(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_48_info *data = (calc_m_0_48_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_49(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_49_info *data = (calc_m_0_49_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_50(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_50_info *data = (calc_m_0_50_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_51(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_51_info *data = (calc_m_0_51_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_0_12_info *data = (averageCellToLonEdge_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_0_12_info *data = (averageCellToLatEdge_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_0_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_0_12_info *data = (interpCellToVtx_0_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_22_info *data = (update_state_0_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stateu_lon = data->old_stateu_lon;
  __attribute__ ((aligned (32))) double old_stateu_lon[10][258];
  
  double *_tend2du = data->tend2du;
  __attribute__ ((aligned (32))) double tend2du[10][258];
  
  double *_new_stateu_lon = data->new_stateu_lon;
  __attribute__ ((aligned (32))) double new_stateu_lon[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib), &tend2du[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib), &tend2du[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateu_lon[j][i] = (old_stateu_lon[swindex[j]][i] + (dt * tend2du[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_0_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_0_23_info *data = (update_state_0_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statev_lat = data->old_statev_lat;
  __attribute__ ((aligned (32))) double old_statev_lat[10][258];
  
  double *_tend2dv = data->tend2dv;
  __attribute__ ((aligned (32))) double tend2dv[10][258];
  
  double *_new_statev_lat = data->new_statev_lat;
  __attribute__ ((aligned (32))) double new_statev_lat[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend2dv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend2dv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statev_lat[j][i] = (old_statev_lat[swindex[j]][i] + (dt * tend2dv[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void smag_damp_run_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_0_info *data = (smag_damp_run_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statesmag_t[j][i] = (((stateu_lon[swindex[j]][i] - stateu_lon[swindex[j]][(i - 1)]) / de_lon[j+jb+oy]) - ((((statev_lat[swindex[j]][i] * half_cos_lat[j+jb+oy]) - (statev_lat[swindex[(j - 1)]][i] * half_cos_lat[(j+jb+oy - 1)])) / le_lon[j+jb+oy]) / full_cos_lat[j+jb+oy]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statesmag_t[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_1_info *data = (smag_damp_run_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statesmag_s[j][i] = (((statev_lat[swindex[j]][(i + 1)] - statev_lat[swindex[j]][i]) / le_lat[j+jb+oy]) + ((((stateu_lon[swindex[(j + 1)]][i] * full_cos_lat[(j+jb+oy + 1)]) - (stateu_lon[swindex[j]][i] * full_cos_lat[j+jb+oy])) / de_lat[j+jb+oy]) / half_cos_lat[j+jb+oy]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statesmag_s[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_2_info *data = (smag_damp_run_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_statekmh_lon = data->statekmh_lon;
  __attribute__ ((aligned (32))) double statekmh_lon[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statekmh_lon[j][i] = ((0.1 / ((1.0 / pow(de_lon[j+jb+oy],2)) + (1 / pow(le_lon[j+jb+oy],2)))) * sqrt(((0.5 * (pow(statesmag_t[swindex[j]][i],2) + pow(statesmag_t[swindex[j]][(i + 1)],2))) + (0.5 * (pow(statesmag_s[swindex[j]][i],2) + pow(statesmag_s[swindex[(j - 1)]][i],2))))));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statekmh_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_3_info *data = (smag_damp_run_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statekmh_lat[j][i] = ((0.1 / ((1.0 / pow(le_lat[j+jb+oy],2)) + (1 / pow(de_lat[j+jb+oy],2)))) * sqrt(((0.5 * (pow(statesmag_t[swindex[j]][i],2) + pow(statesmag_t[swindex[(j + 1)]][i],2))) + (0.5 * (pow(statesmag_s[swindex[j]][i],2) + pow(statesmag_s[swindex[j]][(i - 1)],2))))));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statekmh_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_4_info *data = (smag_damp_run_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lon = data->statekmh_lon;
  __attribute__ ((aligned (32))) double statekmh_lon[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_tendsmag_dudt = data->tendsmag_dudt;
  __attribute__ ((aligned (32))) double tendsmag_dudt[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statekmh_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statekmh_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dudt[j][i] = (statekmh_lon[swindex[j]][i] * ((((stateu_lon[swindex[j]][(i - 1)] - (2 * stateu_lon[swindex[j]][i])) + stateu_lon[swindex[j]][(i + 1)]) / pow(de_lon[j+jb+oy],2)) + ((((((stateu_lon[swindex[(j + 1)]][i] - stateu_lon[swindex[j]][i]) / de_lat[j+jb+oy]) * half_cos_lat[j+jb+oy]) - (((stateu_lon[swindex[j]][i] - stateu_lon[swindex[(j - 1)]][i]) / de_lat[(j+jb+oy - 1)]) * half_cos_lat[(j+jb+oy - 1)])) / le_lon[j+jb+oy]) / full_cos_lat[j+jb+oy])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tendsmag_dudt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_5_info *data = (smag_damp_run_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_tendsmag_dudt = data->tendsmag_dudt;
  __attribute__ ((aligned (32))) double tendsmag_dudt[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib), &tendsmag_dudt[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib), &tendsmag_dudt[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu_lon[j][i] = (stateu_lon[j][i] + (dt * tendsmag_dudt[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_6_info *data = (smag_damp_run_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dvdt[j][i] = (statekmh_lat[swindex[j]][i] * (((statev_lat[swindex[j]][(i - 1)] - (2 * statev_lat[swindex[j]][i])) + statev_lat[swindex[j]][(i + 1)]) / pow(le_lat[j+jb+oy],2)));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tendsmag_dvdt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_7_info *data = (smag_damp_run_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dvdt[j][i] = (statekmh_lat[swindex[j]][i] * ((((statev_lat[swindex[j]][(i - 1)] - (2 * statev_lat[swindex[j]][i])) + statev_lat[swindex[j]][(i + 1)]) / pow(le_lat[j+jb+oy],2)) + ((((((statev_lat[swindex[(j + 1)]][i] - statev_lat[swindex[j]][i]) / le_lon[(j+jb+oy + 1)]) * full_cos_lat[(j+jb+oy + 1)]) - (((statev_lat[swindex[j]][i] - statev_lat[swindex[(j - 1)]][i]) / le_lon[j+jb+oy]) * full_cos_lat[j+jb+oy])) / de_lat[j+jb+oy]) / half_cos_lat[j+jb+oy])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tendsmag_dvdt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_0_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_0_8_info *data = (smag_damp_run_0_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib), &tendsmag_dvdt[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib), &tendsmag_dvdt[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statev_lat[j][i] = (statev_lat[j][i] + (dt * tendsmag_dvdt[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void trickypt_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  trickypt_0_0_info *data = (trickypt_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statept[j][i] = (statept[j][i] * statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_21_info *data = (calc_ph_0_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statephs = data->statephs;
  __attribute__ ((aligned (32))) double statephs[10][258];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_22_info *data = (calc_ph_0_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_stateph_exn_lev = data->stateph_exn_lev;
  __attribute__ ((aligned (32))) double stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_exn_lev[j][i] = pow(stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_0_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_0_23_info *data = (calc_ph_0_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            stateph[k][i] = (0.5 * (stateph_lev[k][i] + stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_52(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_52_info *data = (calc_m_0_52_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][258];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem[k][i] = (stateph_lev[swindex[(k + 1)]][i] - stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_53(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_53_info *data = (calc_m_0_53_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_54(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_54_info *data = (calc_m_0_54_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[8][256];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[8][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[j][i] = (stateph[swindex[j]][i] - stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_0_55(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_0_55_info *data = (calc_m_0_55_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph_lev[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_0_13_info *data = (averageCellToLonEdge_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lon[j][i] = ((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_0_13_info *data = (averageCellToLatEdge_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lat[j][i] = ((statem[swindex[j]][i] + statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_0_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_0_13_info *data = (interpCellToVtx_0_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_vtx[j][i] = ((((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((statem[swindex[(j + 1)]][i] + statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void pole_damp_run_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  pole_damp_run_0_0_info *data = (pole_damp_run_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statept[j][i] = (statept[j][i] / statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void c2a_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  c2a_0_1_info *data = (c2a_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu = data->stateu;
  __attribute__ ((aligned (32))) double stateu[10][258];
  
  double *_statev = data->statev;
  __attribute__ ((aligned (32))) double statev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu[j][i] = (0.5 * (stateu_lon[j][i] + stateu_lon[j][(i - 1)]));
            statev[j][i] = (0.5 * (statev_lat[j][i] + statev_lat[(j - 1)][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}


void accum_uv_cell_0_60(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_60_info *data = (accum_uv_cell_0_60_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advu0 = data->advu0;
  __attribute__ ((aligned (32))) double advu0[8][258];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advu0+(kb*fnumy*fnumx+j*fnumx+ib), &advu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advu0+(kb*fnumy*fnumx+j*fnumx+ib), &advu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = advu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_61(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_61_info *data = (accum_uv_cell_0_61_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advv0 = data->advv0;
  __attribute__ ((aligned (32))) double advv0[10][256];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advv0+(kb*hnumy*hnumx+j*hnumx+ib), &advv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advv0+(kb*hnumy*hnumx+j*hnumx+ib), &advv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = advv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_62(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_62_info *data = (accum_uv_cell_0_62_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = state_oldu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_63(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_63_info *data = (accum_uv_cell_0_63_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = state_oldv_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_64(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_64_info *data = (accum_uv_cell_0_64_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = ((advuu[j][i] + state_oldu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_65(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_65_info *data = (accum_uv_cell_0_65_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = ((advvv[j][i] + state_oldv_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_66(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_66_info *data = (accum_uv_cell_0_66_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  double *_advu0 = data->advu0;
  __attribute__ ((aligned (32))) double advu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advu0[j][i] = advuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_67(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_67_info *data = (accum_uv_cell_0_67_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advv0 = data->advv0;
  __attribute__ ((aligned (32))) double advv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advv0[j][i] = advvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_68(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_68_info *data = (accum_uv_cell_0_68_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = (advuu[j][i] + state_oldu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_69(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_69_info *data = (accum_uv_cell_0_69_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = (advvv[j][i] + state_oldv_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_70(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_70_info *data = (accum_uv_cell_0_70_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcflx[j][i] = ((advuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_71(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_71_info *data = (accum_uv_cell_0_71_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcfly[j][i] = ((advvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_72(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_72_info *data = (accum_uv_cell_0_72_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_advdivx = data->advdivx;
  __attribute__ ((aligned (32))) double advdivx[10][258];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advdivx[j][i] = (((advuu[swindex[j]][i] - advuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advdivy[j][i] = (((advvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_73(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_73_info *data = (accum_uv_cell_0_73_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_oldtmpsum[j][i] = advvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_oldtmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_0_74(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_0_74_info *data = (accum_uv_cell_0_74_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[8][256];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advdivy[j][i] = (((state_oldtmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_24(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_24_info *data = (accum_mf_cell_0_24_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = state_oldmfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_25(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_25_info *data = (accum_mf_cell_0_25_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = state_oldmfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_26(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_26_info *data = (accum_mf_cell_0_26_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = ((advmfx[j][i] + state_oldmfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_27(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_27_info *data = (accum_mf_cell_0_27_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = ((advmfy[j][i] + state_oldmfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_28(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_28_info *data = (accum_mf_cell_0_28_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = (advmfx[j][i] + state_oldmfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_0_29(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_0_29_info *data = (accum_mf_cell_0_29_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = (advmfy[j][i] + state_oldmfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_15_info *data = (accum_we_lev_0_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe0 = data->advwe0;
  __attribute__ ((aligned (32))) double advwe0[8][256];
  
  double *_advm0 = data->advm0;
  __attribute__ ((aligned (32))) double advm0[8][256];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[8][256];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advwe0[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advm0+(kb*fnumy*fnumx+j*fnumx+ib), &advm0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advwe0[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advm0+(kb*fnumy*fnumx+j*fnumx+ib), &advm0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = advwe0[j][i];
            advmm[j][i] = advm0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_16_info *data = (accum_we_lev_0_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = state_oldwe_lev[swindex[j]][i];
            advmm[j][i] = state_oldm_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_17_info *data = (accum_we_lev_0_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  double *_advwe0 = data->advwe0;
  __attribute__ ((aligned (32))) double advwe0[10][258];
  
  double *_advm0 = data->advm0;
  __attribute__ ((aligned (32))) double advm0[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = ((advwe[j][i] + state_oldwe_lev[swindex[j]][i]) / ((nstep) + 1));
            advmm[j][i] = ((advmm[j][i] + state_oldm_lev[swindex[j]][i]) / ((nstep) + 1));
            advwe0[j][i] = state_oldwe_lev[swindex[j]][i];
            advm0[j][i] = state_oldm_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advm0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advm0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_18_info *data = (accum_we_lev_0_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = (advwe[j][i] + state_oldwe_lev[swindex[j]][i]);
            advmm[j][i] = (advmm[j][i] + state_oldm_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_0_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_0_19_info *data = (accum_we_lev_0_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[8][256];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[8][256];
  
  double *_advcflz = data->advcflz;
  __attribute__ ((aligned (32))) double advcflz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcflz[j][i] = ((advwe[swindex[j]][i] / advmm[swindex[j]][i]) * dt);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcflz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advcflz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_0_9_info *data = (hflx_ppm_inner_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[12][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[12][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[12][260];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[12][260];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[12][260];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(state_oldqv[swindex[j]][(i - 2)],state_oldqv[swindex[j]][(i - 1)],state_oldqv[swindex[j]][i],state_oldqv[swindex[j]][(i + 1)],state_oldqv[swindex[j]][(i + 2)]);
            advqlx[j][i] = buf.x;
            advdqx[j][i] = buf.y;
            advq6x[j][i] = buf.z;
            buf = slave_ppm(state_oldqv[swindex[(j - 2)]][i],state_oldqv[swindex[(j - 1)]][i],state_oldqv[swindex[j]][i],state_oldqv[swindex[(j + 1)]][i],state_oldqv[swindex[(j + 2)]][i]);
            advqly[j][i] = buf.x;
            advdqy[j][i] = buf.y;
            advq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_0_10_info *data = (hflx_ppm_inner_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[by+2*hy][bx+2*hx];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[by+2*hy][bx+2*hx];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[by+2*hy][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[by+2*hy][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[by+2*hy][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[by+2*hy][bx+2*hx];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflx[swindex[j]][i]);
            cf = (advcflx[swindex[j]][i] - ci);
            if ((advcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + state_oldqv[swindex[j]][l]);
              }
              advqmf_lon[j][i] = ((advuu[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advdqx[swindex[j]][(i - ci)]) * ds2)) + (advq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
            }
            else
            {
              if ((advcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + state_oldqv[swindex[j]][l]);
                }
                advqmf_lon[j][i] = ((-advuu[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
              }
              else
              {
                advqmf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqmf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_0_11_info *data = (hflx_ppm_inner_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[10][256];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[10][256];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[10][256];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              advqmf_lat[j][i] = ((advvv[swindex[j]][i] * (((advqly[swindex[j]][i] * ds1) + ((0.5 * advdqy[swindex[j]][i]) * ds2)) + (advq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
            }
            else
            {
              if ((advcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                advqmf_lat[j][i] = ((-advvv[swindex[j]][i] * (((advqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advdqy[swindex[(j + 1)]][i]) * ds2)) + (advq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
              }
              else
              {
                advqmf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advqmf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_0_9_info *data = (ffsl_calc_tracer_hflx_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[12][260];
  
  double *_advdivx = data->advdivx;
  __attribute__ ((aligned (32))) double advdivx[12][260];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[12][260];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advdivx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advdivx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advqx[j][i] = (state_oldqv[swindex[j]][i] - ((0.5 * ((((advqmf_lon[swindex[j]][i] - advqmf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]) - (advdivx[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
            advqy[j][i] = (state_oldqv[swindex[j]][i] - ((0.5 * ((((advqmf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (advqmf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) - (advdivy[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_0_10_info *data = (ffsl_calc_tracer_hflx_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_oldtmpsum[j][i] = advqmf_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_oldtmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_0_11_info *data = (ffsl_calc_tracer_hflx_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[12][260];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advqx[j][i] = state_oldqv[swindex[j]][i];
            advqy[j][i] = (state_oldqv[swindex[j]][i] + ((0.5 * ((((state_oldtmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]) - (advdivy[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_0_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_0_9_info *data = (hflx_ppm_outer_0_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[12][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[12][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[12][260];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[12][260];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[12][260];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqx+(kb*fnumy*fnumx+j*fnumx+ib), &advqx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqx+(kb*fnumy*fnumx+j*fnumx+ib), &advqx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(advqy[swindex[j]][(i - 2)],advqy[swindex[j]][(i - 1)],advqy[swindex[j]][i],advqy[swindex[j]][(i + 1)],advqy[swindex[j]][(i + 2)]);
            advqlx[j][i] = buf.x;
            advdqx[j][i] = buf.y;
            advq6x[j][i] = buf.z;
            buf = slave_ppm(advqx[swindex[(j - 2)]][i],advqx[swindex[(j - 1)]][i],advqx[swindex[j]][i],advqx[swindex[(j + 1)]][i],advqx[swindex[(j + 2)]][i]);
            advqly[j][i] = buf.x;
            advdqy[j][i] = buf.y;
            advq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_0_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_0_10_info *data = (hflx_ppm_outer_0_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[by+2*hy][bx+2*hx];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[by+2*hy][bx+2*hx];
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[by+2*hy][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[by+2*hy][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[by+2*hy][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[by+2*hy][bx+2*hx];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflx[swindex[j]][i]);
            cf = (advcflx[swindex[j]][i] - ci);
            if ((advcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + advqy[swindex[j]][l]);
              }
              advqmf_lon[j][i] = ((advmfx[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advdqx[swindex[j]][(i - ci)]) * ds2)) + (advq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
            }
            else
            {
              if ((advcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + advqy[swindex[j]][l]);
                }
                advqmf_lon[j][i] = ((-advmfx[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
              }
              else
              {
                advqmf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqmf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_0_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_0_11_info *data = (hflx_ppm_outer_0_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][256];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[10][256];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[10][256];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[10][256];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              advqmf_lat[j][i] = ((advmfy[swindex[j]][i] * (((advqly[swindex[j]][i] * ds1) + ((0.5 * advdqy[swindex[j]][i]) * ds2)) + (advq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
            }
            else
            {
              if ((advcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                advqmf_lat[j][i] = ((-advmfy[swindex[j]][i] * (((advqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advdqy[swindex[(j + 1)]][i]) * ds2)) + (advq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
              }
              else
              {
                advqmf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advqmf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_0_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_0_0_info *data = (adv_run_0_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[12][260];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[12][260];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[12][260];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (((advold_m[swindex[j]][i] * state_oldqv[swindex[j]][i]) - ((advqmf_lon[swindex[j]][i] - advqmf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy])) + ((((advqmf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (advqmf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) * 30));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_0_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_0_1_info *data = (adv_run_0_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double *_state_newtmpsum = data->state_newtmpsum;
  __attribute__ ((aligned (32))) double state_newtmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newtmpsum[j][i] = advqmf_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newtmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newtmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_0_2_info *data = (adv_run_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[12][260];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_state_newtmpsum = data->state_newtmpsum;
  __attribute__ ((aligned (32))) double state_newtmpsum[12][260];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_newtmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_newtmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = ((advold_m[swindex[j]][i] * state_oldqv[swindex[j]][i]) - ((((state_newtmpsum[swindex[j]][i] * le_lat[j+jb+oy]) / 2400) / area_cell[j+jb+oy]) * 30));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_0_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_0_3_info *data = (adv_run_0_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (state_newqv[j][i] / state_oldm[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_0_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_0_6_info *data = (vflx_ppm_0_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[8][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[8][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[8][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[8][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(state_newqv[swindex[(k - 2)]][i],state_newqv[swindex[(k - 1)]][i],state_newqv[swindex[k]][i],state_newqv[swindex[(k + 1)]][i],state_newqv[swindex[(k + 2)]][i]);
            advqlx[k][i] = buf.x;
            advdqx[k][i] = buf.y;
            advq6x[k][i] = buf.z;
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advqlx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advdqx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advq6x[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_0_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_0_7_info *data = (vflx_ppm_0_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflz = data->advcflz;
  __attribute__ ((aligned (32))) double advcflz[bz+2*hz][bx+2*hx];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[bz+2*hz][bx+2*hx];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[bz+2*hz][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[bz+2*hz][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[bz+2*hz][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[bz+2*hz][bx+2*hx];
  
  double *_advqmf_lev = data->advqmf_lev;
  __attribute__ ((aligned (32))) double advqmf_lev[bz+2*hz][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_advcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advcflz[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advwe+(k*fnumy*fnumx+jb*fnumx+ib), &advwe[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advqlx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advdqx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advq6x[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_advcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advcflz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advwe+(k*fnumy*fnumx+jb*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflz[swindex[k]][i]);
            cf = (advcflz[swindex[k]][i] - ci);
            if ((advcflz[swindex[k]][i] > 0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=(k - ci);l<((k - 1) + 1);l+=1){
                cursum = (cursum + state_newqv[swindex[l]][i]);
              }
              advqmf_lev[k][i] = ((advwe[swindex[k]][i] * (((cursum + (advqlx[swindex[((k - ci) - 1)]][i] * ds1)) + ((0.5 * advdqx[swindex[((k - ci) - 1)]][i]) * ds2)) + (advq6x[swindex[((k - ci) - 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflz[swindex[k]][i]);
            }
            else
            {
              if ((advcflz[swindex[k]][i] < 0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                for (l=k;l<(((k - ci) - 1) + 1);l+=1){
                  cursum = (cursum + state_newqv[swindex[l]][i]);
                }
                advqmf_lev[k][i] = ((-advwe[swindex[k]][i] * (((cursum + (advqlx[swindex[(k - ci)]][i] * ds1)) + ((0.5 * advdqx[swindex[(k - ci)]][i]) * ds2)) + (advq6x[swindex[(k - ci)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflz[swindex[k]][i]);
              }
              else
              {
                advqmf_lev[k][i] = 0.0;
              }
            }
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advqmf_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_0_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_0_4_info *data = (adv_run_0_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[8][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[8][260];
  
  double *_advqmf_lev = data->advqmf_lev;
  __attribute__ ((aligned (32))) double advqmf_lev[8][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(k*fnumy*fnumx+jb*fnumx+ib), &state_oldm[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &advqmf_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(k*fnumy*fnumx+jb*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &advqmf_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[k][i] = ((state_newqv[k][i] * state_oldm[swindex[k]][i]) - ((advqmf_lev[swindex[(k + 1)]][i] - advqmf_lev[swindex[k]][i]) * 30));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib+hx), &state_newqv[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_0_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_0_5_info *data = (adv_run_0_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (state_newqv[j][i] / state_oldm[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void copy_old_m_0_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_0_2_info *data = (copy_old_m_0_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[10][258];
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advold_m[j][i] = state_oldm[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}





void c2a_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  c2a_1_0_info *data = (c2a_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu = data->stateu;
  __attribute__ ((aligned (32))) double stateu[10][258];
  
  double *_statev = data->statev;
  __attribute__ ((aligned (32))) double statev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu[j][i] = (0.5 * (stateu_lon[j][i] + stateu_lon[j][(i - 1)]));
            statev[j][i] = (0.5 * (statev_lat[j][i] + statev_lat[(j - 1)][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void calc_ph_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_0_info *data = (calc_ph_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statephs = data->statephs;
  __attribute__ ((aligned (32))) double statephs[10][258];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_1_info *data = (calc_ph_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_stateph_exn_lev = data->stateph_exn_lev;
  __attribute__ ((aligned (32))) double stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_exn_lev[j][i] = pow(stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_2_info *data = (calc_ph_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            stateph[k][i] = (0.5 * (stateph_lev[k][i] + stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_0_info *data = (calc_m_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][258];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem[k][i] = (stateph_lev[swindex[(k + 1)]][i] - stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_1_info *data = (calc_m_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_2_info *data = (calc_m_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[8][256];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[8][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[j][i] = (stateph[swindex[j]][i] - stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_3_info *data = (calc_m_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph_lev[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_1_0_info *data = (averageCellToLonEdge_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lon[j][i] = ((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_1_0_info *data = (averageCellToLatEdge_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lat[j][i] = ((statem[swindex[j]][i] + statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_1_0_info *data = (interpCellToVtx_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_vtx[j][i] = ((((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((statem[swindex[(j + 1)]][i] + statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_t_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_t_1_0_info *data = (calc_t_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[12][260];
  
  double *_stateqv = data->stateqv;
  __attribute__ ((aligned (32))) double stateqv[12][260];
  
  double *_statet = data->statet;
  __attribute__ ((aligned (32))) double statet[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &stateqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &stateqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statet[j][i] = slave_temperature(statept[swindex[j]][i],stateph[swindex[j]][i],stateqv[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statet+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statet[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_0_info *data = (accum_uv_cell_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = advptu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_1_info *data = (accum_uv_cell_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = advptv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_2_info *data = (accum_uv_cell_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = stateu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_3_info *data = (accum_uv_cell_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_4_info *data = (accum_uv_cell_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = ((advptuu[j][i] + stateu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_5_info *data = (accum_uv_cell_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = ((advptvv[j][i] + statev_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_6_info *data = (accum_uv_cell_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptu0[j][i] = advptuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_7_info *data = (accum_uv_cell_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptv0[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_8_info *data = (accum_uv_cell_1_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = (advptuu[j][i] + stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_9_info *data = (accum_uv_cell_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = (advptvv[j][i] + statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_10_info *data = (accum_uv_cell_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflx[j][i] = ((advptuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_11_info *data = (accum_uv_cell_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcfly[j][i] = ((advptvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_12_info *data = (accum_uv_cell_1_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[10][258];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivx[j][i] = (((advptuu[swindex[j]][i] - advptuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advptdivy[j][i] = (((advptvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advptvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_0_info *data = (calc_mf_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfx_lon[j][i] = (statem_lon[swindex[j]][i] * stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statemfx_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_1_info *data = (calc_mf_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfy_lat[j][i] = (statem_lat[swindex[j]][i] * statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statemfy_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_0_info *data = (accum_mf_cell_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = statemfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_1_info *data = (accum_mf_cell_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = statemfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_2_info *data = (accum_mf_cell_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = ((advptmfx[j][i] + statemfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_3_info *data = (accum_mf_cell_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = ((advptmfy[j][i] + statemfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_4_info *data = (accum_mf_cell_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = (advptmfx[j][i] + statemfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_5_info *data = (accum_mf_cell_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = (advptmfy[j][i] + statemfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_2_info *data = (calc_mf_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  double *_statemfx_lat = data->statemfx_lat;
  __attribute__ ((aligned (32))) double statemfx_lat[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfx_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfx_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfx_lat[j][i] = ((half_tangent_wgt_0[j+jb+oy] * (statemfx_lon[swindex[j]][(i - 1)] + statemfx_lon[swindex[j]][i])) + (half_tangent_wgt_1[j+jb+oy] * (statemfx_lon[swindex[(j + 1)]][(i - 1)] + statemfx_lon[swindex[(j + 1)]][i])));
            stateu_lat[j][i] = (statemfx_lat[j][i] / statem_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statemfx_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &stateu_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_3_info *data = (calc_mf_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  double *_statemfy_lon = data->statemfy_lon;
  __attribute__ ((aligned (32))) double statemfy_lon[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  double *_statev_lon = data->statev_lon;
  __attribute__ ((aligned (32))) double statev_lon[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfy_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfy_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfy_lon[j][i] = ((full_tangent_wgt_0[j+jb+oy] * (statemfy_lat[swindex[(j - 1)]][i] + statemfy_lat[swindex[(j - 1)]][(i + 1)])) + (full_tangent_wgt_1[j+jb+oy] * (statemfy_lat[swindex[j]][i] + statemfy_lat[swindex[j]][(i + 1)])));
            statev_lon[j][i] = (statemfy_lon[j][i] / statem_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statemfy_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_1_0_info *data = (calc_ke_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = (((((area_lon_west[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2)) + (area_lon_east[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) + (area_lat_north[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2))) + (area_lat_south[j+jb+oy] * pow(statev_lat[swindex[j]][i],2))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_1_1_info *data = (calc_ke_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  double *_area_lat_east = data->area_lat_east;
  __attribute__ ((aligned (32))) double area_lat_east[hny+2*hy];
  
  double *_area_lat_west = data->area_lat_west;
  __attribute__ ((aligned (32))) double area_lat_west[hny+2*hy];
  
  double *_area_lon_north = data->area_lon_north;
  __attribute__ ((aligned (32))) double area_lon_north[fny+2*hy];
  
  double *_area_lon_south = data->area_lon_south;
  __attribute__ ((aligned (32))) double area_lon_south[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_east+(ghy-hy), &area_lat_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_west+(ghy-hy), &area_lat_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_north+(ghy-hy), &area_lon_north[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_south+(ghy-hy), &area_lon_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = ((((1.0 - 0.5) * ((((((((area_lat_east[j+jb+oy] * pow(statev_lat[swindex[j]][(i - 1)],2)) + (area_lat_west[j+jb+oy] * pow(statev_lat[swindex[j]][i],2))) + (area_lon_north[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(stateu_lon[swindex[(j + 1)]][(i - 1)],2))) / area_vtx[j+jb+oy]) + (((((area_lat_east[j+jb+oy] * pow(statev_lat[swindex[j]][i],2)) + (area_lat_west[j+jb+oy] * pow(statev_lat[swindex[j]][(i + 1)],2))) + (area_lon_north[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(stateu_lon[swindex[(j + 1)]][i],2))) / area_vtx[j+jb+oy])) * area_subcell_1[j+jb+oy]) + (((((((area_lat_east[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][(i - 1)],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(stateu_lon[swindex[(j - 1)]][(i - 1)],2))) + (area_lon_south[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2))) / area_vtx[(j+jb+oy - 1)]) + (((((area_lat_east[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][(i + 1)],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(stateu_lon[swindex[(j - 1)]][i],2))) + (area_lon_south[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) / area_vtx[(j+jb+oy - 1)])) * area_subcell_0[j+jb+oy]))) / area_cell[j+jb+oy]) + (0.5 * stateke[j][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_1_0_info *data = (calc_vor_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statevor[j][i] = ((((stateu_lon[swindex[j]][i] * de_lon[j+jb+oy]) - (stateu_lon[swindex[(j + 1)]][i] * de_lon[(j+jb+oy + 1)])) + ((statev_lat[swindex[j]][(i + 1)] * de_lat[j+jb+oy]) - (statev_lat[swindex[j]][i] * de_lat[j+jb+oy]))) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_pv_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_pv_1_0_info *data = (calc_pv_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[12][260];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_half_f = data->half_f;
  __attribute__ ((aligned (32))) double half_f[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_f+(ghy-hy), &half_f[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &statevor[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &statem_vtx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &statevor[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &statem_vtx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statepv[j][i] = ((statevor[swindex[j]][i] + half_f[j+jb+oy]) / statem_vtx[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statepv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_1_0_info *data = (interp_pv_upwind_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lon = data->statev_lon;
  __attribute__ ((aligned (32))) double statev_lon[12][260];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_statepv_lon = data->statepv_lon;
  __attribute__ ((aligned (32))) double statepv_lon[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statev_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(statev_lon[swindex[j]][i]) / (sqrt((pow(stateu_lon[swindex[j]][i],2) + pow(statev_lon[swindex[j]][i],2))) + 1e-24));
            statepv_lon[j][i] = ((b * slave_upwind3(sign(1.0,statev_lon[swindex[j]][i]),1,statepv[swindex[(j - 2)]][i],statepv[swindex[(j - 1)]][i],statepv[swindex[j]][i],statepv[swindex[(j + 1)]][i])) + (((1 - b) * 0.5) * (statepv[swindex[(j - 1)]][i] + statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statepv_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_1_1_info *data = (interp_pv_upwind_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[12][260];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_statepv_lat = data->statepv_lat;
  __attribute__ ((aligned (32))) double statepv_lat[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(stateu_lat[swindex[j]][i]) / (sqrt((pow(stateu_lat[swindex[j]][i],2) + pow(statev_lat[swindex[j]][i],2))) + 1e-24));
            statepv_lat[j][i] = ((b * slave_upwind3(sign(1.0,stateu_lat[swindex[j]][i]),1,statepv[swindex[j]][(i - 2)],statepv[swindex[j]][(i - 1)],statepv[swindex[j]][i],statepv[swindex[j]][(i + 1)])) + (((1 - b) * 0.5) * (statepv[swindex[j]][(i - 1)] + statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statepv_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_1_0_info *data = (calc_div_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statediv = data->statediv;
  __attribute__ ((aligned (32))) double statediv[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statediv[j][i] = ((((stateu_lon[swindex[j]][i] * le_lon[j+jb+oy]) - (stateu_lon[swindex[j]][(i - 1)] * le_lon[j+jb+oy])) + ((statev_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (statev_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)]))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_gz_lev_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_gz_lev_1_0_info *data = (calc_gz_lev_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statet = data->statet;
  __attribute__ ((aligned (32))) double statet[bz+2*hz][bx+2*hx];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[bz+2*hz][bx+2*hx];
  
  double *_staticvgzs = data->staticvgzs;
  __attribute__ ((aligned (32))) double staticvgzs[bz+2*hz][bx+2*hx];
  
  double *_stategz_lev = data->stategz_lev;
  __attribute__ ((aligned (32))) double stategz_lev[bz+2*hz][bx+2*hx];
  
  double dgz;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_statet+(k*fnumy*fnumx+jb*fnumx+ib), &statet[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(jb*fnumx+ib), &staticvgzs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_statet+(k*fnumy*fnumx+jb*fnumx+ib), &statet[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(k*fnumy*fnumx+jb*fnumx+ib), &staticvgzs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            dgz = 0.0;
            for (l=k;l<((32 - 1) + 1)+ghz;l+=1){
              dgz = (dgz + ((287.04 * statet[swindex[l]][i]) * log((stateph_lev[swindex[(l + 1)]][i] / stateph_lev[swindex[l]][i]))));
            }
            stategz_lev[k][i] = (staticvgzs[swindex[0]][i] + dgz);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stategz_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void copy_old_m_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_1_0_info *data = (copy_old_m_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_advmold_m = data->advmold_m;
  __attribute__ ((aligned (32))) double advmold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmold_m[j][i] = statem[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void copy_old_m_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_1_1_info *data = (copy_old_m_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_advptold_m = data->advptold_m;
  __attribute__ ((aligned (32))) double advptold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptold_m[j][i] = statem[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}


void accum_uv_cell_1_39(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_39_info *data = (accum_uv_cell_1_39_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = advptu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_40(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_40_info *data = (accum_uv_cell_1_40_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = advptv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_41(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_41_info *data = (accum_uv_cell_1_41_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = star_stateu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_42(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_42_info *data = (accum_uv_cell_1_42_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = star_statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_43(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_43_info *data = (accum_uv_cell_1_43_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = ((advptuu[j][i] + star_stateu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_44(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_44_info *data = (accum_uv_cell_1_44_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = ((advptvv[j][i] + star_statev_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_45(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_45_info *data = (accum_uv_cell_1_45_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptu0[j][i] = advptuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_46(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_46_info *data = (accum_uv_cell_1_46_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptv0[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_47(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_47_info *data = (accum_uv_cell_1_47_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = (advptuu[j][i] + star_stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_48(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_48_info *data = (accum_uv_cell_1_48_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = (advptvv[j][i] + star_statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_49(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_49_info *data = (accum_uv_cell_1_49_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflx[j][i] = ((advptuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_50(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_50_info *data = (accum_uv_cell_1_50_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcfly[j][i] = ((advptvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_51(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_51_info *data = (accum_uv_cell_1_51_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[10][258];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivx[j][i] = (((advptuu[swindex[j]][i] - advptuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advptdivy[j][i] = (((advptvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advptvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_12_info *data = (calc_mf_1_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfx_lon[j][i] = (star_statem_lon[swindex[j]][i] * star_stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statemfx_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_13_info *data = (calc_mf_1_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfy_lat[j][i] = (star_statem_lat[swindex[j]][i] * star_statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statemfy_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_18_info *data = (accum_mf_cell_1_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = star_statemfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_19_info *data = (accum_mf_cell_1_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = star_statemfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_20_info *data = (accum_mf_cell_1_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = ((advptmfx[j][i] + star_statemfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_21_info *data = (accum_mf_cell_1_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = ((advptmfy[j][i] + star_statemfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_22_info *data = (accum_mf_cell_1_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = (advptmfx[j][i] + star_statemfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_23_info *data = (accum_mf_cell_1_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = (advptmfy[j][i] + star_statemfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_14_info *data = (calc_mf_1_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_star_statemfx_lat = data->star_statemfx_lat;
  __attribute__ ((aligned (32))) double star_statemfx_lat[10][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[10][258];
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfx_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfx_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfx_lat[j][i] = ((half_tangent_wgt_0[j+jb+oy] * (star_statemfx_lon[swindex[j]][(i - 1)] + star_statemfx_lon[swindex[j]][i])) + (half_tangent_wgt_1[j+jb+oy] * (star_statemfx_lon[swindex[(j + 1)]][(i - 1)] + star_statemfx_lon[swindex[(j + 1)]][i])));
            star_stateu_lat[j][i] = (star_statemfx_lat[j][i] / star_statem_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statemfx_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateu_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_1_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_1_15_info *data = (calc_mf_1_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statemfy_lon = data->star_statemfy_lon;
  __attribute__ ((aligned (32))) double star_statemfy_lon[10][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[10][258];
  
  double *_star_statev_lon = data->star_statev_lon;
  __attribute__ ((aligned (32))) double star_statev_lon[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfy_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfy_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfy_lon[j][i] = ((full_tangent_wgt_0[j+jb+oy] * (star_statemfy_lat[swindex[(j - 1)]][i] + star_statemfy_lat[swindex[(j - 1)]][(i + 1)])) + (full_tangent_wgt_1[j+jb+oy] * (star_statemfy_lat[swindex[j]][i] + star_statemfy_lat[swindex[j]][(i + 1)])));
            star_statev_lon[j][i] = (star_statemfy_lon[j][i] / star_statem_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statemfy_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_1_6_info *data = (calc_ke_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = (((((area_lon_west[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2)) + (area_lon_east[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) + (area_lat_north[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2))) + (area_lat_south[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_1_7_info *data = (calc_ke_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_area_lat_east = data->area_lat_east;
  __attribute__ ((aligned (32))) double area_lat_east[hny+2*hy];
  
  double *_area_lat_west = data->area_lat_west;
  __attribute__ ((aligned (32))) double area_lat_west[hny+2*hy];
  
  double *_area_lon_north = data->area_lon_north;
  __attribute__ ((aligned (32))) double area_lon_north[fny+2*hy];
  
  double *_area_lon_south = data->area_lon_south;
  __attribute__ ((aligned (32))) double area_lon_south[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_east+(ghy-hy), &area_lat_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_west+(ghy-hy), &area_lat_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_north+(ghy-hy), &area_lon_north[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_south+(ghy-hy), &area_lon_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = ((((1.0 - 0.5) * ((((((((area_lat_east[j+jb+oy] * pow(star_statev_lat[swindex[j]][(i - 1)],2)) + (area_lat_west[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2))) + (area_lon_north[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(star_stateu_lon[swindex[(j + 1)]][(i - 1)],2))) / area_vtx[j+jb+oy]) + (((((area_lat_east[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2)) + (area_lat_west[j+jb+oy] * pow(star_statev_lat[swindex[j]][(i + 1)],2))) + (area_lon_north[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(star_stateu_lon[swindex[(j + 1)]][i],2))) / area_vtx[j+jb+oy])) * area_subcell_1[j+jb+oy]) + (((((((area_lat_east[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][(i - 1)],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(star_stateu_lon[swindex[(j - 1)]][(i - 1)],2))) + (area_lon_south[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2))) / area_vtx[(j+jb+oy - 1)]) + (((((area_lat_east[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][(i + 1)],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(star_stateu_lon[swindex[(j - 1)]][i],2))) + (area_lon_south[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) / area_vtx[(j+jb+oy - 1)])) * area_subcell_0[j+jb+oy]))) / area_cell[j+jb+oy]) + (0.5 * star_stateke[j][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_1_3_info *data = (calc_div_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statediv = data->star_statediv;
  __attribute__ ((aligned (32))) double star_statediv[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statediv[j][i] = ((((star_stateu_lon[swindex[j]][i] * le_lon[j+jb+oy]) - (star_stateu_lon[swindex[j]][(i - 1)] * le_lon[j+jb+oy])) + ((star_statev_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_statev_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)]))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_1_3_info *data = (calc_vor_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statevor[j][i] = ((((star_stateu_lon[swindex[j]][i] * de_lon[j+jb+oy]) - (star_stateu_lon[swindex[(j + 1)]][i] * de_lon[(j+jb+oy + 1)])) + ((star_statev_lat[swindex[j]][(i + 1)] * de_lat[j+jb+oy]) - (star_statev_lat[swindex[j]][i] * de_lat[j+jb+oy]))) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_pv_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_pv_1_3_info *data = (calc_pv_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[12][260];
  
  double *_star_statem_vtx = data->star_statem_vtx;
  __attribute__ ((aligned (32))) double star_statem_vtx[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_half_f = data->half_f;
  __attribute__ ((aligned (32))) double half_f[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_f+(ghy-hy), &half_f[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &star_statevor[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_vtx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &star_statevor[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_vtx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statepv[j][i] = ((star_statevor[swindex[j]][i] + half_f[j+jb+oy]) / star_statem_vtx[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statepv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_1_6_info *data = (interp_pv_upwind_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lon = data->star_statev_lon;
  __attribute__ ((aligned (32))) double star_statev_lon[12][260];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statev_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(star_statev_lon[swindex[j]][i]) / (sqrt((pow(star_stateu_lon[swindex[j]][i],2) + pow(star_statev_lon[swindex[j]][i],2))) + 1e-24));
            star_statepv_lon[j][i] = ((b * slave_upwind3(sign(1.0,star_statev_lon[swindex[j]][i]),1,star_statepv[swindex[(j - 2)]][i],star_statepv[swindex[(j - 1)]][i],star_statepv[swindex[j]][i],star_statepv[swindex[(j + 1)]][i])) + (((1 - b) * 0.5) * (star_statepv[swindex[(j - 1)]][i] + star_statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statepv_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_1_7_info *data = (interp_pv_upwind_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[12][260];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(star_stateu_lat[swindex[j]][i]) / (sqrt((pow(star_stateu_lat[swindex[j]][i],2) + pow(star_statev_lat[swindex[j]][i],2))) + 1e-24));
            star_statepv_lat[j][i] = ((b * slave_upwind3(sign(1.0,star_stateu_lat[swindex[j]][i]),1,star_statepv[swindex[j]][(i - 2)],star_statepv[swindex[j]][(i - 1)],star_statepv[swindex[j]][i],star_statepv[swindex[j]][(i + 1)])) + (((1 - b) * 0.5) * (star_statepv[swindex[j]][(i - 1)] + star_statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statepv_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_1_4_info *data = (calc_grad_mf_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_tend1dmfdlon = data->tend1dmfdlon;
  __attribute__ ((aligned (32))) double tend1dmfdlon[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlon[j][i] = (((star_statemfx_lon[swindex[j]][i] - star_statemfx_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_1_5_info *data = (calc_grad_mf_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlat[j][i] = (((star_statemfy_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_statemfy_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_we_lev_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_we_lev_1_2_info *data = (calc_we_lev_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dmfdlon = data->tend1dmfdlon;
  __attribute__ ((aligned (32))) double tend1dmfdlon[bz+2*hz][bx+2*hx];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[bz+2*hz][bx+2*hx];
  
  double *_tend1dphs = data->tend1dphs;
  __attribute__ ((aligned (32))) double tend1dphs[bz+2*hz][bx+2*hx];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[bz+2*hz][bx+2*hx];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  double mfs;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_tend1dmfdlon+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dmfdlat+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dphs+(jb*fnumx+ib), &tend1dphs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_tend1dmfdlon+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dmfdlat+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dphs+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dphs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            mfs = 0.0;
            for (l=0+ghz;l<((k - 1) + 1);l+=1){
              mfs = ((mfs + tend1dmfdlon[swindex[l]][i]) + tend1dmfdlat[swindex[l]][i]);
            }
            star_statewe_lev[k][i] = (-slave_hybrid_coord_calc_dphdt_lev(hybi[k+kb+oz],tend1dphs[swindex[0]][i]) - mfs);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_statewe_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_statewe_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_10_info *data = (accum_we_lev_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe0 = data->advptwe0;
  __attribute__ ((aligned (32))) double advptwe0[8][256];
  
  double *_advptm0 = data->advptm0;
  __attribute__ ((aligned (32))) double advptm0[8][256];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[8][256];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe0[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib), &advptm0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe0[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib), &advptm0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = advptwe0[j][i];
            advptmm[j][i] = advptm0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_11_info *data = (accum_we_lev_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = star_statewe_lev[swindex[j]][i];
            advptmm[j][i] = star_statem_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_12_info *data = (accum_we_lev_1_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  double *_advptwe0 = data->advptwe0;
  __attribute__ ((aligned (32))) double advptwe0[10][258];
  
  double *_advptm0 = data->advptm0;
  __attribute__ ((aligned (32))) double advptm0[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = ((advptwe[j][i] + star_statewe_lev[swindex[j]][i]) / ((nstep) + 1));
            advptmm[j][i] = ((advptmm[j][i] + star_statem_lev[swindex[j]][i]) / ((nstep) + 1));
            advptwe0[j][i] = star_statewe_lev[swindex[j]][i];
            advptm0[j][i] = star_statem_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptm0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_13_info *data = (accum_we_lev_1_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = (advptwe[j][i] + star_statewe_lev[swindex[j]][i]);
            advptmm[j][i] = (advptmm[j][i] + star_statem_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_14_info *data = (accum_we_lev_1_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[8][256];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[8][256];
  
  double *_advptcflz = data->advptcflz;
  __attribute__ ((aligned (32))) double advptcflz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflz[j][i] = ((advptwe[swindex[j]][i] / advptmm[swindex[j]][i]) * dt);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_lev_edge_to_lev_lon_edge_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_lev_edge_to_lev_lon_edge_1_2_info *data = (interp_lev_edge_to_lev_lon_edge_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lon = data->area_lon;
  __attribute__ ((aligned (32))) double area_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon+(ghy-hy), &area_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statewe_lev_lon[j][i] = (((area_lon_west[j+jb+oy] * star_statewe_lev[swindex[j]][i]) + (area_lon_east[j+jb+oy] * star_statewe_lev[swindex[j]][(i + 1)])) / area_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statewe_lev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statewe_lev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_lev_edge_to_lev_lat_edge_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_lev_edge_to_lev_lat_edge_1_2_info *data = (interp_lev_edge_to_lev_lat_edge_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[10][258];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_lat = data->area_lat;
  __attribute__ ((aligned (32))) double area_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat+(ghy-hy), &area_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statewe_lev_lat[j][i] = (((area_lat_north[j+jb+oy] * star_statewe_lev[swindex[(j + 1)]][i]) + (area_lat_south[j+jb+oy] * star_statewe_lev[swindex[j]][i])) / area_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statewe_lev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statewe_lev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_1_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_1_8_info *data = (calc_wedudlev_wedvdlev_1_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[6][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[6][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[6][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedudlev[k][i] = ((((star_statewe_lev_lon[swindex[(k + 1)]][i] * (star_stateu_lon[swindex[(k + 1)]][i] - star_stateu_lon[swindex[k]][i])) + (star_statewe_lev_lon[swindex[k]][i] * (star_stateu_lon[swindex[k]][i] - star_stateu_lon[swindex[(k - 1)]][i]))) / star_statem_lon[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedudlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1wedudlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_1_9_info *data = (calc_wedudlev_wedvdlev_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[6][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[6][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[6][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedudlev[k][i] = (((star_statewe_lev_lon[swindex[k]][i] * (star_stateu_lon[swindex[k]][i] - star_stateu_lon[swindex[(k - 1)]][i])) / star_statem_lon[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedudlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1wedudlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_1_10_info *data = (calc_wedudlev_wedvdlev_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[6][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[6][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[6][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedvdlev[k][i] = ((((star_statewe_lev_lat[swindex[(k + 1)]][i] * (star_statev_lat[swindex[(k + 1)]][i] - star_statev_lat[swindex[k]][i])) + (star_statewe_lev_lat[swindex[k]][i] * (star_statev_lat[swindex[k]][i] - star_statev_lat[swindex[(k - 1)]][i]))) / star_statem_lat[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedvdlev+(k*hnumy*hnumx+jb*hnumx+ib+hx), &tend1wedvdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_1_11_info *data = (calc_wedudlev_wedvdlev_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[6][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[6][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[6][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedvdlev[k][i] = (((star_statewe_lev_lat[swindex[k]][i] * (star_statev_lat[swindex[k]][i] - star_statev_lat[swindex[(k - 1)]][i])) / star_statem_lat[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedvdlev+(k*hnumy*hnumx+jb*hnumx+ib+hx), &tend1wedvdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_1_6_info *data = (hflx_ppm_inner_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[12][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[12][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[12][260];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[12][260];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[12][260];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(star_statept[swindex[j]][(i - 2)],star_statept[swindex[j]][(i - 1)],star_statept[swindex[j]][i],star_statept[swindex[j]][(i + 1)],star_statept[swindex[j]][(i + 2)]);
            advptqlx[j][i] = buf.x;
            advptdqx[j][i] = buf.y;
            advptq6x[j][i] = buf.z;
            buf = slave_ppm(star_statept[swindex[(j - 2)]][i],star_statept[swindex[(j - 1)]][i],star_statept[swindex[j]][i],star_statept[swindex[(j + 1)]][i],star_statept[swindex[(j + 2)]][i]);
            advptqly[j][i] = buf.x;
            advptdqy[j][i] = buf.y;
            advptq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_1_7_info *data = (hflx_ppm_inner_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[by+2*hy][bx+2*hx];
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[by+2*hy][bx+2*hx];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[by+2*hy][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[by+2*hy][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[by+2*hy][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[by+2*hy][bx+2*hx];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflx[swindex[j]][i]);
            cf = (advptcflx[swindex[j]][i] - ci);
            if ((advptcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + star_statept[swindex[j]][l]);
              }
              star_stateptf_lon[j][i] = ((advptuu[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advptdqx[swindex[j]][(i - ci)]) * ds2)) + (advptq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
            }
            else
            {
              if ((advptcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + star_statept[swindex[j]][l]);
                }
                star_stateptf_lon[j][i] = ((-advptuu[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advptdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advptq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateptf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_1_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_1_8_info *data = (hflx_ppm_inner_1_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[10][256];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[10][256];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[10][256];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advptcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advptcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              star_stateptf_lat[j][i] = ((advptvv[swindex[j]][i] * (((advptqly[swindex[j]][i] * ds1) + ((0.5 * advptdqy[swindex[j]][i]) * ds2)) + (advptq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
            }
            else
            {
              if ((advptcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advptcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                star_stateptf_lat[j][i] = ((-advptvv[swindex[j]][i] * (((advptqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advptdqy[swindex[(j + 1)]][i]) * ds2)) + (advptq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateptf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_1_2_info *data = (ffsl_calc_tracer_hflx_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[12][260];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[12][260];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[12][260];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptqx[j][i] = (star_statept[swindex[j]][i] - ((0.5 * ((((star_stateptf_lon[swindex[j]][i] - star_stateptf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]) - (advptdivx[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
            advptqy[j][i] = (star_statept[swindex[j]][i] - ((0.5 * ((((star_stateptf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_stateptf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) - (advptdivy[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_1_6_info *data = (hflx_ppm_outer_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[12][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[12][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[12][260];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[12][260];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[12][260];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(advptqy[swindex[j]][(i - 2)],advptqy[swindex[j]][(i - 1)],advptqy[swindex[j]][i],advptqy[swindex[j]][(i + 1)],advptqy[swindex[j]][(i + 2)]);
            advptqlx[j][i] = buf.x;
            advptdqx[j][i] = buf.y;
            advptq6x[j][i] = buf.z;
            buf = slave_ppm(advptqx[swindex[(j - 2)]][i],advptqx[swindex[(j - 1)]][i],advptqx[swindex[j]][i],advptqx[swindex[(j + 1)]][i],advptqx[swindex[(j + 2)]][i]);
            advptqly[j][i] = buf.x;
            advptdqy[j][i] = buf.y;
            advptq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_1_7_info *data = (hflx_ppm_outer_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[by+2*hy][bx+2*hx];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[by+2*hy][bx+2*hx];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[by+2*hy][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[by+2*hy][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[by+2*hy][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[by+2*hy][bx+2*hx];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflx[swindex[j]][i]);
            cf = (advptcflx[swindex[j]][i] - ci);
            if ((advptcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + advptqy[swindex[j]][l]);
              }
              star_stateptf_lon[j][i] = ((advptmfx[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advptdqx[swindex[j]][(i - ci)]) * ds2)) + (advptq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
            }
            else
            {
              if ((advptcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + advptqy[swindex[j]][l]);
                }
                star_stateptf_lon[j][i] = ((-advptmfx[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advptdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advptq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateptf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_1_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_1_8_info *data = (hflx_ppm_outer_1_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][256];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[10][256];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[10][256];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[10][256];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advptcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advptcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              star_stateptf_lat[j][i] = ((advptmfy[swindex[j]][i] * (((advptqly[swindex[j]][i] * ds1) + ((0.5 * advptdqy[swindex[j]][i]) * ds2)) + (advptq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
            }
            else
            {
              if ((advptcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advptcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                star_stateptf_lat[j][i] = ((-advptmfy[swindex[j]][i] * (((advptqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advptdqy[swindex[(j + 1)]][i]) * ds2)) + (advptq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateptf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_1_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_1_8_info *data = (calc_grad_ptf_1_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[8][258];
  
  double *_tend1dptfdlon = data->tend1dptfdlon;
  __attribute__ ((aligned (32))) double tend1dptfdlon[8][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlon[j][i] = (((star_stateptf_lon[swindex[j]][i] - star_stateptf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_1_9_info *data = (calc_grad_ptf_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[10][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlat[j][i] = (((star_stateptf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_stateptf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_1_10_info *data = (calc_grad_ptf_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[8][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            star_statept[k][i] = ((2 * star_statept[(k - 1)][i]) - star_statept[(k - 2)][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_statept[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_1_4_info *data = (vflx_ppm_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[8][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[8][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[8][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[8][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(star_statept[swindex[(k - 2)]][i],star_statept[swindex[(k - 1)]][i],star_statept[swindex[k]][i],star_statept[swindex[(k + 1)]][i],star_statept[swindex[(k + 2)]][i]);
            advptqlx[k][i] = buf.x;
            advptdqx[k][i] = buf.y;
            advptq6x[k][i] = buf.z;
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptqlx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptdqx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptq6x[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_1_5_info *data = (vflx_ppm_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflz = data->advptcflz;
  __attribute__ ((aligned (32))) double advptcflz[bz+2*hz][bx+2*hx];
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[bz+2*hz][bx+2*hx];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[bz+2*hz][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[bz+2*hz][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[bz+2*hz][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[bz+2*hz][bx+2*hx];
  
  double *_star_stateptf_lev = data->star_stateptf_lev;
  __attribute__ ((aligned (32))) double star_stateptf_lev[bz+2*hz][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_advptcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advptcflz[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptwe+(k*fnumy*fnumx+jb*fnumx+ib), &advptwe[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advptqlx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advptdqx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advptq6x[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_advptcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advptcflz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptwe+(k*fnumy*fnumx+jb*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflz[swindex[k]][i]);
            cf = (advptcflz[swindex[k]][i] - ci);
            if ((advptcflz[swindex[k]][i] > 0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=(k - ci);l<((k - 1) + 1);l+=1){
                cursum = (cursum + star_statept[swindex[l]][i]);
              }
              star_stateptf_lev[k][i] = ((advptwe[swindex[k]][i] * (((cursum + (advptqlx[swindex[((k - ci) - 1)]][i] * ds1)) + ((0.5 * advptdqx[swindex[((k - ci) - 1)]][i]) * ds2)) + (advptq6x[swindex[((k - ci) - 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflz[swindex[k]][i]);
            }
            else
            {
              if ((advptcflz[swindex[k]][i] < 0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                for (l=k;l<(((k - ci) - 1) + 1);l+=1){
                  cursum = (cursum + star_statept[swindex[l]][i]);
                }
                star_stateptf_lev[k][i] = ((-advptwe[swindex[k]][i] * (((cursum + (advptqlx[swindex[(k - ci)]][i] * ds1)) + ((0.5 * advptdqx[swindex[(k - ci)]][i]) * ds2)) + (advptq6x[swindex[(k - ci)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflz[swindex[k]][i]);
              }
              else
              {
                star_stateptf_lev[k][i] = 0.0;
              }
            }
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_stateptf_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_1_11_info *data = (calc_grad_ptf_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lev = data->star_stateptf_lev;
  __attribute__ ((aligned (32))) double star_stateptf_lev[6][256];
  
  double *_tend1dptfdlev = data->tend1dptfdlev;
  __attribute__ ((aligned (32))) double tend1dptfdlev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateptf_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateptf_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlev[k][i] = (star_stateptf_lev[swindex[(k + 1)]][i] - star_stateptf_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1dptfdlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1dptfdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_coriolis_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_coriolis_1_4_info *data = (calc_coriolis_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[10][258];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[10][258];
  
  double *_tend1qhu = data->tend1qhu;
  __attribute__ ((aligned (32))) double tend1qhu[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1qhu[j][i] = (((half_tangent_wgt_0[j+jb+oy] * ((star_statemfx_lon[swindex[j]][(i - 1)] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[j]][(i - 1)])) + (star_statemfx_lon[swindex[j]][i] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[j]][i])))) + (half_tangent_wgt_1[j+jb+oy] * ((star_statemfx_lon[swindex[(j + 1)]][(i - 1)] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[(j + 1)]][(i - 1)])) + (star_statemfx_lon[swindex[(j + 1)]][i] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[(j + 1)]][i]))))) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1qhu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_coriolis_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_coriolis_1_5_info *data = (calc_coriolis_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[10][258];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[10][258];
  
  double *_tend1qhv = data->tend1qhv;
  __attribute__ ((aligned (32))) double tend1qhv[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1qhv[j][i] = (((full_tangent_wgt_0[j+jb+oy] * ((star_statemfy_lat[swindex[(j - 1)]][i] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[(j - 1)]][i])) + (star_statemfy_lat[swindex[(j - 1)]][(i + 1)] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[(j - 1)]][(i + 1)])))) + (full_tangent_wgt_1[j+jb+oy] * ((star_statemfy_lat[swindex[j]][i] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[j]][i])) + (star_statemfy_lat[swindex[j]][(i + 1)] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[j]][(i + 1)]))))) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1qhv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ke_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ke_1_4_info *data = (calc_grad_ke_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_tend1dkedlon = data->tend1dkedlon;
  __attribute__ ((aligned (32))) double tend1dkedlon[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dkedlon[j][i] = ((star_stateke[swindex[j]][(i + 1)] - star_stateke[swindex[j]][i]) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dkedlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ke_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ke_1_5_info *data = (calc_grad_ke_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_tend1dkedlat = data->tend1dkedlat;
  __attribute__ ((aligned (32))) double tend1dkedlat[10][258];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dkedlat[j][i] = ((star_stateke[swindex[(j + 1)]][i] - star_stateke[swindex[j]][i]) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1dkedlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_1_6_info *data = (calc_tend_forward_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1qhv = data->tend1qhv;
  __attribute__ ((aligned (32))) double tend1qhv[10][258];
  
  double *_tend1dkedlon = data->tend1dkedlon;
  __attribute__ ((aligned (32))) double tend1dkedlon[10][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[10][258];
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib), &tend1qhv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dkedlon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedudlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1wedudlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib), &tend1qhv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dkedlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedudlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1wedudlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1du[j][i] = ((tend1qhv[swindex[j]][i] - tend1dkedlon[swindex[j]][i]) - tend1wedudlev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1du[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_1_7_info *data = (calc_tend_forward_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1qhu = data->tend1qhu;
  __attribute__ ((aligned (32))) double tend1qhu[10][258];
  
  double *_tend1dkedlat = data->tend1dkedlat;
  __attribute__ ((aligned (32))) double tend1dkedlat[10][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[10][258];
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib), &tend1qhu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dkedlat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedvdlev+(kb*hnumy*hnumx+j*hnumx+ib), &tend1wedvdlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib), &tend1qhu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dkedlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedvdlev+(kb*hnumy*hnumx+j*hnumx+ib), &tend1wedvdlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dv[j][i] = ((-tend1qhu[swindex[j]][i] - tend1dkedlat[swindex[j]][i]) - tend1wedvdlev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1dv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_1_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_1_8_info *data = (calc_tend_forward_1_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dptfdlon = data->tend1dptfdlon;
  __attribute__ ((aligned (32))) double tend1dptfdlon[10][258];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[10][258];
  
  double *_tend1dptfdlev = data->tend1dptfdlev;
  __attribute__ ((aligned (32))) double tend1dptfdlev[10][258];
  
  double *_tend1dpt = data->tend1dpt;
  __attribute__ ((aligned (32))) double tend1dpt[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dpt[j][i] = ((-tend1dptfdlon[j][i] - tend1dptfdlat[j][i]) - tend1dptfdlev[j][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dpt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_15_info *data = (calc_ph_1_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statephs = data->new_statephs;
  __attribute__ ((aligned (32))) double new_statephs[10][258];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],new_statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_16_info *data = (calc_ph_1_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_exn_lev[j][i] = pow(new_stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_17_info *data = (calc_ph_1_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph[k][i] = (0.5 * (new_stateph_lev[k][i] + new_stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_36(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_36_info *data = (calc_m_1_36_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_37(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_37_info *data = (calc_m_1_37_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_38(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_38_info *data = (calc_m_1_38_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_39(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_39_info *data = (calc_m_1_39_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_1_9_info *data = (averageCellToLonEdge_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_1_9_info *data = (averageCellToLatEdge_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_1_9_info *data = (interpCellToVtx_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_16_info *data = (update_state_1_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statept = data->old_statept;
  __attribute__ ((aligned (32))) double old_statept[12][260];
  
  double *_old_statem = data->old_statem;
  __attribute__ ((aligned (32))) double old_statem[12][260];
  
  double *_tend1dpt = data->tend1dpt;
  __attribute__ ((aligned (32))) double tend1dpt[12][260];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[12][260];
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dpt[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dpt[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statept[j][i] = (((old_statept[swindex[j]][i] * old_statem[swindex[j]][i]) + (dt * tend1dpt[swindex[j]][i])) / new_statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_17_info *data = (update_state_1_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stategz = data->old_stategz;
  __attribute__ ((aligned (32))) double old_stategz[8][256];
  
  double *_tend1dgz = data->tend1dgz;
  __attribute__ ((aligned (32))) double tend1dgz[8][256];
  
  double *_new_stategz = data->new_stategz;
  __attribute__ ((aligned (32))) double new_stategz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dgz[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dgz[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stategz[j][i] = (old_stategz[swindex[j]][i] + (dt * tend1dgz[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stategz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stategz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_40(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_40_info *data = (calc_m_1_40_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_41(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_41_info *data = (calc_m_1_41_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_42(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_42_info *data = (calc_m_1_42_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_43(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_43_info *data = (calc_m_1_43_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_1_10_info *data = (averageCellToLonEdge_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_1_10_info *data = (averageCellToLatEdge_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_1_10_info *data = (interpCellToVtx_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_18_info *data = (update_state_1_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stateu_lon = data->old_stateu_lon;
  __attribute__ ((aligned (32))) double old_stateu_lon[10][258];
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  double *_new_stateu_lon = data->new_stateu_lon;
  __attribute__ ((aligned (32))) double new_stateu_lon[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateu_lon[j][i] = (old_stateu_lon[swindex[j]][i] + (dt * tend1du[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_19_info *data = (update_state_1_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statev_lat = data->old_statev_lat;
  __attribute__ ((aligned (32))) double old_statev_lat[10][258];
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  double *_new_statev_lat = data->new_statev_lat;
  __attribute__ ((aligned (32))) double new_statev_lat[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statev_lat[j][i] = (old_statev_lat[swindex[j]][i] + (dt * tend1dv[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_t_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_t_1_3_info *data = (calc_t_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[12][260];
  
  double *_new_stateqv = data->new_stateqv;
  __attribute__ ((aligned (32))) double new_stateqv[12][260];
  
  double *_new_statet = data->new_statet;
  __attribute__ ((aligned (32))) double new_statet[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib), &new_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib), &new_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statet[j][i] = slave_temperature(new_statept[swindex[j]][i],new_stateph[swindex[j]][i],new_stateqv[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statet+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statet[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_gz_lev_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_gz_lev_1_3_info *data = (calc_gz_lev_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statet = data->new_statet;
  __attribute__ ((aligned (32))) double new_statet[bz+2*hz][bx+2*hx];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[bz+2*hz][bx+2*hx];
  
  double *_staticvgzs = data->staticvgzs;
  __attribute__ ((aligned (32))) double staticvgzs[bz+2*hz][bx+2*hx];
  
  double *_new_stategz_lev = data->new_stategz_lev;
  __attribute__ ((aligned (32))) double new_stategz_lev[bz+2*hz][bx+2*hx];
  
  double dgz;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_statet+(k*fnumy*fnumx+jb*fnumx+ib), &new_statet[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(jb*fnumx+ib), &staticvgzs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_statet+(k*fnumy*fnumx+jb*fnumx+ib), &new_statet[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(k*fnumy*fnumx+jb*fnumx+ib), &staticvgzs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            dgz = 0.0;
            for (l=k;l<((32 - 1) + 1)+ghz;l+=1){
              dgz = (dgz + ((287.04 * new_statet[swindex[l]][i]) * log((new_stateph_lev[swindex[(l + 1)]][i] / new_stateph_lev[swindex[l]][i]))));
            }
            new_stategz_lev[k][i] = (staticvgzs[swindex[0]][i] + dgz);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stategz_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void pgf_lin97_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  pgf_lin97_1_2_info *data = (pgf_lin97_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateqm = data->new_stateqm;
  __attribute__ ((aligned (32))) double new_stateqm[6][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[6][258];
  
  double *_new_stategz_lev = data->new_stategz_lev;
  __attribute__ ((aligned (32))) double new_stategz_lev[6][258];
  
  double *_tend2pgf_lon = data->tend2pgf_lon;
  __attribute__ ((aligned (32))) double tend2pgf_lon[6][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double tl;
  double dph1;
  double dph2;
  double dgz1;
  double dgz2;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateqm+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateqm[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_exn_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_exn_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stategz_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateqm+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateqm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_exn_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_exn_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stategz_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tl = (1 + (0.5 * (new_stateqm[swindex[k]][i] + new_stateqm[swindex[k]][(i + 1)])));
            dph1 = (new_stateph_exn_lev[swindex[(k + 1)]][(i + 1)] - new_stateph_exn_lev[swindex[k]][i]);
            dph2 = (new_stateph_exn_lev[swindex[(k + 1)]][i] - new_stateph_exn_lev[swindex[k]][(i + 1)]);
            dgz1 = (new_stategz_lev[swindex[(k + 1)]][i] - new_stategz_lev[swindex[k]][(i + 1)]);
            dgz2 = (new_stategz_lev[swindex[k]][i] - new_stategz_lev[swindex[(k + 1)]][(i + 1)]);
            tend2pgf_lon[k][i] = (((-((dph1 * dgz1) + (dph2 * dgz2)) / de_lon[jb+oy]) / (dph1 + dph2)) / tl);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend2pgf_lon+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend2pgf_lon[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_backward_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_backward_1_4_info *data = (calc_tend_backward_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  double *_tend2pgf_lon = data->tend2pgf_lon;
  __attribute__ ((aligned (32))) double tend2pgf_lon[10][258];
  
  double *_tend2du = data->tend2du;
  __attribute__ ((aligned (32))) double tend2du[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &tend2pgf_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &tend2pgf_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend2du[j][i] = (tend1du[swindex[j]][i] - tend2pgf_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend2du[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_backward_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_backward_1_5_info *data = (calc_tend_backward_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  double *_tend2pgf_lat = data->tend2pgf_lat;
  __attribute__ ((aligned (32))) double tend2pgf_lat[10][258];
  
  double *_tend2dv = data->tend2dv;
  __attribute__ ((aligned (32))) double tend2dv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &tend2pgf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &tend2pgf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend2dv[j][i] = (tend1dv[swindex[j]][i] - tend2pgf_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend2dv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_18_info *data = (calc_ph_1_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statephs = data->new_statephs;
  __attribute__ ((aligned (32))) double new_statephs[10][258];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],new_statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_19_info *data = (calc_ph_1_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_exn_lev[j][i] = pow(new_stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_20_info *data = (calc_ph_1_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph[k][i] = (0.5 * (new_stateph_lev[k][i] + new_stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_44(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_44_info *data = (calc_m_1_44_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_45(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_45_info *data = (calc_m_1_45_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_46(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_46_info *data = (calc_m_1_46_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_47(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_47_info *data = (calc_m_1_47_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_1_11_info *data = (averageCellToLonEdge_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_1_11_info *data = (averageCellToLatEdge_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_1_11_info *data = (interpCellToVtx_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_20_info *data = (update_state_1_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statept = data->old_statept;
  __attribute__ ((aligned (32))) double old_statept[12][260];
  
  double *_old_statem = data->old_statem;
  __attribute__ ((aligned (32))) double old_statem[12][260];
  
  double *_tend2dpt = data->tend2dpt;
  __attribute__ ((aligned (32))) double tend2dpt[12][260];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[12][260];
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dpt[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dpt[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statept[j][i] = (((old_statept[swindex[j]][i] * old_statem[swindex[j]][i]) + (dt * tend2dpt[swindex[j]][i])) / new_statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_21_info *data = (update_state_1_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stategz = data->old_stategz;
  __attribute__ ((aligned (32))) double old_stategz[8][256];
  
  double *_tend2dgz = data->tend2dgz;
  __attribute__ ((aligned (32))) double tend2dgz[8][256];
  
  double *_new_stategz = data->new_stategz;
  __attribute__ ((aligned (32))) double new_stategz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dgz[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dgz[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stategz[j][i] = (old_stategz[swindex[j]][i] + (dt * tend2dgz[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stategz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stategz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_48(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_48_info *data = (calc_m_1_48_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_49(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_49_info *data = (calc_m_1_49_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_50(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_50_info *data = (calc_m_1_50_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_51(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_51_info *data = (calc_m_1_51_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_1_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_1_12_info *data = (averageCellToLonEdge_1_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_1_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_1_12_info *data = (averageCellToLatEdge_1_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_1_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_1_12_info *data = (interpCellToVtx_1_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_22_info *data = (update_state_1_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stateu_lon = data->old_stateu_lon;
  __attribute__ ((aligned (32))) double old_stateu_lon[10][258];
  
  double *_tend2du = data->tend2du;
  __attribute__ ((aligned (32))) double tend2du[10][258];
  
  double *_new_stateu_lon = data->new_stateu_lon;
  __attribute__ ((aligned (32))) double new_stateu_lon[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib), &tend2du[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib), &tend2du[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateu_lon[j][i] = (old_stateu_lon[swindex[j]][i] + (dt * tend2du[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_1_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_1_23_info *data = (update_state_1_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statev_lat = data->old_statev_lat;
  __attribute__ ((aligned (32))) double old_statev_lat[10][258];
  
  double *_tend2dv = data->tend2dv;
  __attribute__ ((aligned (32))) double tend2dv[10][258];
  
  double *_new_statev_lat = data->new_statev_lat;
  __attribute__ ((aligned (32))) double new_statev_lat[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend2dv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend2dv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statev_lat[j][i] = (old_statev_lat[swindex[j]][i] + (dt * tend2dv[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void smag_damp_run_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_0_info *data = (smag_damp_run_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statesmag_t[j][i] = (((stateu_lon[swindex[j]][i] - stateu_lon[swindex[j]][(i - 1)]) / de_lon[j+jb+oy]) - ((((statev_lat[swindex[j]][i] * half_cos_lat[j+jb+oy]) - (statev_lat[swindex[(j - 1)]][i] * half_cos_lat[(j+jb+oy - 1)])) / le_lon[j+jb+oy]) / full_cos_lat[j+jb+oy]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statesmag_t[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_1_info *data = (smag_damp_run_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statesmag_s[j][i] = (((statev_lat[swindex[j]][(i + 1)] - statev_lat[swindex[j]][i]) / le_lat[j+jb+oy]) + ((((stateu_lon[swindex[(j + 1)]][i] * full_cos_lat[(j+jb+oy + 1)]) - (stateu_lon[swindex[j]][i] * full_cos_lat[j+jb+oy])) / de_lat[j+jb+oy]) / half_cos_lat[j+jb+oy]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statesmag_s[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_2_info *data = (smag_damp_run_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_statekmh_lon = data->statekmh_lon;
  __attribute__ ((aligned (32))) double statekmh_lon[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statekmh_lon[j][i] = ((0.1 / ((1.0 / pow(de_lon[j+jb+oy],2)) + (1 / pow(le_lon[j+jb+oy],2)))) * sqrt(((0.5 * (pow(statesmag_t[swindex[j]][i],2) + pow(statesmag_t[swindex[j]][(i + 1)],2))) + (0.5 * (pow(statesmag_s[swindex[j]][i],2) + pow(statesmag_s[swindex[(j - 1)]][i],2))))));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statekmh_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_3_info *data = (smag_damp_run_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statekmh_lat[j][i] = ((0.1 / ((1.0 / pow(le_lat[j+jb+oy],2)) + (1 / pow(de_lat[j+jb+oy],2)))) * sqrt(((0.5 * (pow(statesmag_t[swindex[j]][i],2) + pow(statesmag_t[swindex[(j + 1)]][i],2))) + (0.5 * (pow(statesmag_s[swindex[j]][i],2) + pow(statesmag_s[swindex[j]][(i - 1)],2))))));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statekmh_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_1_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_4_info *data = (smag_damp_run_1_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lon = data->statekmh_lon;
  __attribute__ ((aligned (32))) double statekmh_lon[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_tendsmag_dudt = data->tendsmag_dudt;
  __attribute__ ((aligned (32))) double tendsmag_dudt[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statekmh_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statekmh_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dudt[j][i] = (statekmh_lon[swindex[j]][i] * ((((stateu_lon[swindex[j]][(i - 1)] - (2 * stateu_lon[swindex[j]][i])) + stateu_lon[swindex[j]][(i + 1)]) / pow(de_lon[j+jb+oy],2)) + ((((((stateu_lon[swindex[(j + 1)]][i] - stateu_lon[swindex[j]][i]) / de_lat[j+jb+oy]) * half_cos_lat[j+jb+oy]) - (((stateu_lon[swindex[j]][i] - stateu_lon[swindex[(j - 1)]][i]) / de_lat[(j+jb+oy - 1)]) * half_cos_lat[(j+jb+oy - 1)])) / le_lon[j+jb+oy]) / full_cos_lat[j+jb+oy])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tendsmag_dudt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_1_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_5_info *data = (smag_damp_run_1_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_tendsmag_dudt = data->tendsmag_dudt;
  __attribute__ ((aligned (32))) double tendsmag_dudt[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib), &tendsmag_dudt[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib), &tendsmag_dudt[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu_lon[j][i] = (stateu_lon[j][i] + (dt * tendsmag_dudt[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_6_info *data = (smag_damp_run_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dvdt[j][i] = (statekmh_lat[swindex[j]][i] * ((((statev_lat[swindex[j]][(i - 1)] - (2 * statev_lat[swindex[j]][i])) + statev_lat[swindex[j]][(i + 1)]) / pow(le_lat[j+jb+oy],2)) + ((((((statev_lat[swindex[(j + 1)]][i] - statev_lat[swindex[j]][i]) / le_lon[(j+jb+oy + 1)]) * full_cos_lat[(j+jb+oy + 1)]) - (((statev_lat[swindex[j]][i] - statev_lat[swindex[(j - 1)]][i]) / le_lon[j+jb+oy]) * full_cos_lat[j+jb+oy])) / de_lat[j+jb+oy]) / half_cos_lat[j+jb+oy])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tendsmag_dvdt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_1_7_info *data = (smag_damp_run_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib), &tendsmag_dvdt[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib), &tendsmag_dvdt[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statev_lat[j][i] = (statev_lat[j][i] + (dt * tendsmag_dvdt[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void trickypt_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  trickypt_1_0_info *data = (trickypt_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statept[j][i] = (statept[j][i] * statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_21_info *data = (calc_ph_1_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statephs = data->statephs;
  __attribute__ ((aligned (32))) double statephs[10][258];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_22_info *data = (calc_ph_1_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_stateph_exn_lev = data->stateph_exn_lev;
  __attribute__ ((aligned (32))) double stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_exn_lev[j][i] = pow(stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_1_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_1_23_info *data = (calc_ph_1_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            stateph[k][i] = (0.5 * (stateph_lev[k][i] + stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_52(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_52_info *data = (calc_m_1_52_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][258];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem[k][i] = (stateph_lev[swindex[(k + 1)]][i] - stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_53(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_53_info *data = (calc_m_1_53_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_54(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_54_info *data = (calc_m_1_54_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[8][256];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[8][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[j][i] = (stateph[swindex[j]][i] - stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_1_55(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_1_55_info *data = (calc_m_1_55_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph_lev[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_1_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_1_13_info *data = (averageCellToLonEdge_1_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lon[j][i] = ((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_1_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_1_13_info *data = (averageCellToLatEdge_1_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lat[j][i] = ((statem[swindex[j]][i] + statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_1_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_1_13_info *data = (interpCellToVtx_1_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_vtx[j][i] = ((((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((statem[swindex[(j + 1)]][i] + statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void pole_damp_run_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  pole_damp_run_1_0_info *data = (pole_damp_run_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statept[j][i] = (statept[j][i] / statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void c2a_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  c2a_1_1_info *data = (c2a_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu = data->stateu;
  __attribute__ ((aligned (32))) double stateu[10][258];
  
  double *_statev = data->statev;
  __attribute__ ((aligned (32))) double statev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu[j][i] = (0.5 * (stateu_lon[j][i] + stateu_lon[j][(i - 1)]));
            statev[j][i] = (0.5 * (statev_lat[j][i] + statev_lat[(j - 1)][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}


void accum_uv_cell_1_52(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_52_info *data = (accum_uv_cell_1_52_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advu0 = data->advu0;
  __attribute__ ((aligned (32))) double advu0[8][258];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advu0+(kb*fnumy*fnumx+j*fnumx+ib), &advu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advu0+(kb*fnumy*fnumx+j*fnumx+ib), &advu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = advu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_53(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_53_info *data = (accum_uv_cell_1_53_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advv0 = data->advv0;
  __attribute__ ((aligned (32))) double advv0[10][256];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advv0+(kb*hnumy*hnumx+j*hnumx+ib), &advv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advv0+(kb*hnumy*hnumx+j*hnumx+ib), &advv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = advv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_54(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_54_info *data = (accum_uv_cell_1_54_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = state_oldu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_55(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_55_info *data = (accum_uv_cell_1_55_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = state_oldv_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_56(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_56_info *data = (accum_uv_cell_1_56_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = ((advuu[j][i] + state_oldu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_57(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_57_info *data = (accum_uv_cell_1_57_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = ((advvv[j][i] + state_oldv_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_58(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_58_info *data = (accum_uv_cell_1_58_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  double *_advu0 = data->advu0;
  __attribute__ ((aligned (32))) double advu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advu0[j][i] = advuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_59(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_59_info *data = (accum_uv_cell_1_59_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advv0 = data->advv0;
  __attribute__ ((aligned (32))) double advv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advv0[j][i] = advvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_60(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_60_info *data = (accum_uv_cell_1_60_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = (advuu[j][i] + state_oldu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_61(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_61_info *data = (accum_uv_cell_1_61_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = (advvv[j][i] + state_oldv_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_62(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_62_info *data = (accum_uv_cell_1_62_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcflx[j][i] = ((advuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_63(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_63_info *data = (accum_uv_cell_1_63_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcfly[j][i] = ((advvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_1_64(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_1_64_info *data = (accum_uv_cell_1_64_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_advdivx = data->advdivx;
  __attribute__ ((aligned (32))) double advdivx[10][258];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advdivx[j][i] = (((advuu[swindex[j]][i] - advuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advdivy[j][i] = (((advvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_24(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_24_info *data = (accum_mf_cell_1_24_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = state_oldmfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_25(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_25_info *data = (accum_mf_cell_1_25_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = state_oldmfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_26(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_26_info *data = (accum_mf_cell_1_26_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = ((advmfx[j][i] + state_oldmfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_27(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_27_info *data = (accum_mf_cell_1_27_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = ((advmfy[j][i] + state_oldmfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_28(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_28_info *data = (accum_mf_cell_1_28_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = (advmfx[j][i] + state_oldmfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_1_29(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_1_29_info *data = (accum_mf_cell_1_29_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = (advmfy[j][i] + state_oldmfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_15_info *data = (accum_we_lev_1_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe0 = data->advwe0;
  __attribute__ ((aligned (32))) double advwe0[8][256];
  
  double *_advm0 = data->advm0;
  __attribute__ ((aligned (32))) double advm0[8][256];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[8][256];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advwe0[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advm0+(kb*fnumy*fnumx+j*fnumx+ib), &advm0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advwe0[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advm0+(kb*fnumy*fnumx+j*fnumx+ib), &advm0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = advwe0[j][i];
            advmm[j][i] = advm0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_16_info *data = (accum_we_lev_1_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = state_oldwe_lev[swindex[j]][i];
            advmm[j][i] = state_oldm_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_17_info *data = (accum_we_lev_1_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  double *_advwe0 = data->advwe0;
  __attribute__ ((aligned (32))) double advwe0[10][258];
  
  double *_advm0 = data->advm0;
  __attribute__ ((aligned (32))) double advm0[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = ((advwe[j][i] + state_oldwe_lev[swindex[j]][i]) / ((nstep) + 1));
            advmm[j][i] = ((advmm[j][i] + state_oldm_lev[swindex[j]][i]) / ((nstep) + 1));
            advwe0[j][i] = state_oldwe_lev[swindex[j]][i];
            advm0[j][i] = state_oldm_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advm0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advm0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_18_info *data = (accum_we_lev_1_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = (advwe[j][i] + state_oldwe_lev[swindex[j]][i]);
            advmm[j][i] = (advmm[j][i] + state_oldm_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_1_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_1_19_info *data = (accum_we_lev_1_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[8][256];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[8][256];
  
  double *_advcflz = data->advcflz;
  __attribute__ ((aligned (32))) double advcflz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcflz[j][i] = ((advwe[swindex[j]][i] / advmm[swindex[j]][i]) * dt);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcflz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advcflz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_1_9_info *data = (hflx_ppm_inner_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[12][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[12][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[12][260];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[12][260];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[12][260];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(state_oldqv[swindex[j]][(i - 2)],state_oldqv[swindex[j]][(i - 1)],state_oldqv[swindex[j]][i],state_oldqv[swindex[j]][(i + 1)],state_oldqv[swindex[j]][(i + 2)]);
            advqlx[j][i] = buf.x;
            advdqx[j][i] = buf.y;
            advq6x[j][i] = buf.z;
            buf = slave_ppm(state_oldqv[swindex[(j - 2)]][i],state_oldqv[swindex[(j - 1)]][i],state_oldqv[swindex[j]][i],state_oldqv[swindex[(j + 1)]][i],state_oldqv[swindex[(j + 2)]][i]);
            advqly[j][i] = buf.x;
            advdqy[j][i] = buf.y;
            advq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_1_10_info *data = (hflx_ppm_inner_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[by+2*hy][bx+2*hx];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[by+2*hy][bx+2*hx];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[by+2*hy][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[by+2*hy][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[by+2*hy][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[by+2*hy][bx+2*hx];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflx[swindex[j]][i]);
            cf = (advcflx[swindex[j]][i] - ci);
            if ((advcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + state_oldqv[swindex[j]][l]);
              }
              advqmf_lon[j][i] = ((advuu[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advdqx[swindex[j]][(i - ci)]) * ds2)) + (advq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
            }
            else
            {
              if ((advcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + state_oldqv[swindex[j]][l]);
                }
                advqmf_lon[j][i] = ((-advuu[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
              }
              else
              {
                advqmf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqmf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_1_11_info *data = (hflx_ppm_inner_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[10][256];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[10][256];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[10][256];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              advqmf_lat[j][i] = ((advvv[swindex[j]][i] * (((advqly[swindex[j]][i] * ds1) + ((0.5 * advdqy[swindex[j]][i]) * ds2)) + (advq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
            }
            else
            {
              if ((advcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                advqmf_lat[j][i] = ((-advvv[swindex[j]][i] * (((advqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advdqy[swindex[(j + 1)]][i]) * ds2)) + (advq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
              }
              else
              {
                advqmf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advqmf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_1_3_info *data = (ffsl_calc_tracer_hflx_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[12][260];
  
  double *_advdivx = data->advdivx;
  __attribute__ ((aligned (32))) double advdivx[12][260];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[12][260];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advdivx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advdivx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advqx[j][i] = (state_oldqv[swindex[j]][i] - ((0.5 * ((((advqmf_lon[swindex[j]][i] - advqmf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]) - (advdivx[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
            advqy[j][i] = (state_oldqv[swindex[j]][i] - ((0.5 * ((((advqmf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (advqmf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) - (advdivy[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_1_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_1_9_info *data = (hflx_ppm_outer_1_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[12][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[12][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[12][260];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[12][260];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[12][260];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqx+(kb*fnumy*fnumx+j*fnumx+ib), &advqx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqx+(kb*fnumy*fnumx+j*fnumx+ib), &advqx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(advqy[swindex[j]][(i - 2)],advqy[swindex[j]][(i - 1)],advqy[swindex[j]][i],advqy[swindex[j]][(i + 1)],advqy[swindex[j]][(i + 2)]);
            advqlx[j][i] = buf.x;
            advdqx[j][i] = buf.y;
            advq6x[j][i] = buf.z;
            buf = slave_ppm(advqx[swindex[(j - 2)]][i],advqx[swindex[(j - 1)]][i],advqx[swindex[j]][i],advqx[swindex[(j + 1)]][i],advqx[swindex[(j + 2)]][i]);
            advqly[j][i] = buf.x;
            advdqy[j][i] = buf.y;
            advq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_1_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_1_10_info *data = (hflx_ppm_outer_1_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[by+2*hy][bx+2*hx];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[by+2*hy][bx+2*hx];
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[by+2*hy][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[by+2*hy][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[by+2*hy][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[by+2*hy][bx+2*hx];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflx[swindex[j]][i]);
            cf = (advcflx[swindex[j]][i] - ci);
            if ((advcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + advqy[swindex[j]][l]);
              }
              advqmf_lon[j][i] = ((advmfx[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advdqx[swindex[j]][(i - ci)]) * ds2)) + (advq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
            }
            else
            {
              if ((advcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + advqy[swindex[j]][l]);
                }
                advqmf_lon[j][i] = ((-advmfx[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
              }
              else
              {
                advqmf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqmf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_1_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_1_11_info *data = (hflx_ppm_outer_1_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][256];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[10][256];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[10][256];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[10][256];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              advqmf_lat[j][i] = ((advmfy[swindex[j]][i] * (((advqly[swindex[j]][i] * ds1) + ((0.5 * advdqy[swindex[j]][i]) * ds2)) + (advq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
            }
            else
            {
              if ((advcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                advqmf_lat[j][i] = ((-advmfy[swindex[j]][i] * (((advqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advdqy[swindex[(j + 1)]][i]) * ds2)) + (advq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
              }
              else
              {
                advqmf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advqmf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_1_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_1_0_info *data = (adv_run_1_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[12][260];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[12][260];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[12][260];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (((advold_m[swindex[j]][i] * state_oldqv[swindex[j]][i]) - ((advqmf_lon[swindex[j]][i] - advqmf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy])) + ((((advqmf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (advqmf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) * 30));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_1_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_1_1_info *data = (adv_run_1_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (state_newqv[j][i] / state_oldm[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_1_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_1_6_info *data = (vflx_ppm_1_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[8][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[8][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[8][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[8][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(state_newqv[swindex[(k - 2)]][i],state_newqv[swindex[(k - 1)]][i],state_newqv[swindex[k]][i],state_newqv[swindex[(k + 1)]][i],state_newqv[swindex[(k + 2)]][i]);
            advqlx[k][i] = buf.x;
            advdqx[k][i] = buf.y;
            advq6x[k][i] = buf.z;
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advqlx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advdqx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advq6x[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_1_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_1_7_info *data = (vflx_ppm_1_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflz = data->advcflz;
  __attribute__ ((aligned (32))) double advcflz[bz+2*hz][bx+2*hx];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[bz+2*hz][bx+2*hx];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[bz+2*hz][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[bz+2*hz][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[bz+2*hz][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[bz+2*hz][bx+2*hx];
  
  double *_advqmf_lev = data->advqmf_lev;
  __attribute__ ((aligned (32))) double advqmf_lev[bz+2*hz][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_advcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advcflz[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advwe+(k*fnumy*fnumx+jb*fnumx+ib), &advwe[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advqlx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advdqx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advq6x[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_advcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advcflz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advwe+(k*fnumy*fnumx+jb*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflz[swindex[k]][i]);
            cf = (advcflz[swindex[k]][i] - ci);
            if ((advcflz[swindex[k]][i] > 0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=(k - ci);l<((k - 1) + 1);l+=1){
                cursum = (cursum + state_newqv[swindex[l]][i]);
              }
              advqmf_lev[k][i] = ((advwe[swindex[k]][i] * (((cursum + (advqlx[swindex[((k - ci) - 1)]][i] * ds1)) + ((0.5 * advdqx[swindex[((k - ci) - 1)]][i]) * ds2)) + (advq6x[swindex[((k - ci) - 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflz[swindex[k]][i]);
            }
            else
            {
              if ((advcflz[swindex[k]][i] < 0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                for (l=k;l<(((k - ci) - 1) + 1);l+=1){
                  cursum = (cursum + state_newqv[swindex[l]][i]);
                }
                advqmf_lev[k][i] = ((-advwe[swindex[k]][i] * (((cursum + (advqlx[swindex[(k - ci)]][i] * ds1)) + ((0.5 * advdqx[swindex[(k - ci)]][i]) * ds2)) + (advq6x[swindex[(k - ci)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflz[swindex[k]][i]);
              }
              else
              {
                advqmf_lev[k][i] = 0.0;
              }
            }
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advqmf_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_1_2_info *data = (adv_run_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[8][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[8][260];
  
  double *_advqmf_lev = data->advqmf_lev;
  __attribute__ ((aligned (32))) double advqmf_lev[8][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(k*fnumy*fnumx+jb*fnumx+ib), &state_oldm[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &advqmf_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(k*fnumy*fnumx+jb*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &advqmf_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[k][i] = ((state_newqv[k][i] * state_oldm[swindex[k]][i]) - ((advqmf_lev[swindex[(k + 1)]][i] - advqmf_lev[swindex[k]][i]) * 30));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib+hx), &state_newqv[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_1_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_1_3_info *data = (adv_run_1_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (state_newqv[j][i] / state_oldm[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void copy_old_m_1_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_1_2_info *data = (copy_old_m_1_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[10][258];
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advold_m[j][i] = state_oldm[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}





void c2a_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  c2a_2_0_info *data = (c2a_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu = data->stateu;
  __attribute__ ((aligned (32))) double stateu[10][258];
  
  double *_statev = data->statev;
  __attribute__ ((aligned (32))) double statev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu[j][i] = (0.5 * (stateu_lon[j][i] + stateu_lon[j][(i - 1)]));
            statev[j][i] = (0.5 * (statev_lat[j][i] + statev_lat[(j - 1)][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void calc_ph_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_0_info *data = (calc_ph_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statephs = data->statephs;
  __attribute__ ((aligned (32))) double statephs[10][258];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_1_info *data = (calc_ph_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_stateph_exn_lev = data->stateph_exn_lev;
  __attribute__ ((aligned (32))) double stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_exn_lev[j][i] = pow(stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_2_info *data = (calc_ph_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            stateph[k][i] = (0.5 * (stateph_lev[k][i] + stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_0_info *data = (calc_m_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][258];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem[k][i] = (stateph_lev[swindex[(k + 1)]][i] - stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_1_info *data = (calc_m_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_2_info *data = (calc_m_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[8][256];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[8][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[j][i] = (stateph[swindex[j]][i] - stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_3_info *data = (calc_m_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph_lev[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_2_0_info *data = (averageCellToLonEdge_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lon[j][i] = ((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_2_0_info *data = (averageCellToLatEdge_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lat[j][i] = ((statem[swindex[j]][i] + statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_2_0_info *data = (interpCellToVtx_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_vtx[j][i] = ((((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((statem[swindex[(j + 1)]][i] + statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_t_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_t_2_0_info *data = (calc_t_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[12][260];
  
  double *_stateqv = data->stateqv;
  __attribute__ ((aligned (32))) double stateqv[12][260];
  
  double *_statet = data->statet;
  __attribute__ ((aligned (32))) double statet[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &stateqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &stateqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statet[j][i] = slave_temperature(statept[swindex[j]][i],stateph[swindex[j]][i],stateqv[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statet+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statet[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_0_info *data = (accum_uv_cell_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = advptu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_1_info *data = (accum_uv_cell_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = advptv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_2_info *data = (accum_uv_cell_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = stateu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_3_info *data = (accum_uv_cell_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_4_info *data = (accum_uv_cell_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = ((advptuu[j][i] + stateu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_5_info *data = (accum_uv_cell_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = ((advptvv[j][i] + statev_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_6_info *data = (accum_uv_cell_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptu0[j][i] = advptuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_7_info *data = (accum_uv_cell_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptv0[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_8_info *data = (accum_uv_cell_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = (advptuu[j][i] + stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_9_info *data = (accum_uv_cell_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = (advptvv[j][i] + statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_10_info *data = (accum_uv_cell_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflx[j][i] = ((advptuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_11_info *data = (accum_uv_cell_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcfly[j][i] = ((advptvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_12_info *data = (accum_uv_cell_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[10][258];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivx[j][i] = (((advptuu[swindex[j]][i] - advptuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advptdivy[j][i] = (((advptvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advptvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_13_info *data = (accum_uv_cell_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = -advptvv[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_14_info *data = (accum_uv_cell_2_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[8][256];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivy[j][i] = (((statetmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_0_info *data = (calc_mf_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfx_lon[j][i] = (statem_lon[swindex[j]][i] * stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statemfx_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_1_info *data = (calc_mf_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfy_lat[j][i] = (statem_lat[swindex[j]][i] * statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statemfy_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_0_info *data = (accum_mf_cell_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = statemfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_1_info *data = (accum_mf_cell_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = statemfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_2_info *data = (accum_mf_cell_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = ((advptmfx[j][i] + statemfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_3_info *data = (accum_mf_cell_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = ((advptmfy[j][i] + statemfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_4_info *data = (accum_mf_cell_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = (advptmfx[j][i] + statemfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_5_info *data = (accum_mf_cell_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = (advptmfy[j][i] + statemfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_2_info *data = (calc_mf_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfx_lon = data->statemfx_lon;
  __attribute__ ((aligned (32))) double statemfx_lon[10][258];
  
  double *_statemfx_lat = data->statemfx_lat;
  __attribute__ ((aligned (32))) double statemfx_lat[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfx_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfx_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfx_lat[j][i] = ((half_tangent_wgt_0[j+jb+oy] * (statemfx_lon[swindex[j]][(i - 1)] + statemfx_lon[swindex[j]][i])) + (half_tangent_wgt_1[j+jb+oy] * (statemfx_lon[swindex[(j + 1)]][(i - 1)] + statemfx_lon[swindex[(j + 1)]][i])));
            stateu_lat[j][i] = (statemfx_lat[j][i] / statem_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statemfx_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &stateu_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_3_info *data = (calc_mf_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statemfy_lat = data->statemfy_lat;
  __attribute__ ((aligned (32))) double statemfy_lat[10][258];
  
  double *_statemfy_lon = data->statemfy_lon;
  __attribute__ ((aligned (32))) double statemfy_lon[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  double *_statev_lon = data->statev_lon;
  __attribute__ ((aligned (32))) double statev_lon[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfy_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statemfy_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statemfy_lon[j][i] = ((full_tangent_wgt_0[j+jb+oy] * (statemfy_lat[swindex[(j - 1)]][i] + statemfy_lat[swindex[(j - 1)]][(i + 1)])) + (full_tangent_wgt_1[j+jb+oy] * (statemfy_lat[swindex[j]][i] + statemfy_lat[swindex[j]][(i + 1)])));
            statev_lon[j][i] = (statemfy_lon[j][i] / statem_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statemfy_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_0_info *data = (calc_ke_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = (((((area_lon_west[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2)) + (area_lon_east[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) + (area_lat_north[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2))) + (area_lat_south[j+jb+oy] * pow(statev_lat[swindex[j]][i],2))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_1_info *data = (calc_ke_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  double *_area_lat_east = data->area_lat_east;
  __attribute__ ((aligned (32))) double area_lat_east[hny+2*hy];
  
  double *_area_lat_west = data->area_lat_west;
  __attribute__ ((aligned (32))) double area_lat_west[hny+2*hy];
  
  double *_area_lon_north = data->area_lon_north;
  __attribute__ ((aligned (32))) double area_lon_north[fny+2*hy];
  
  double *_area_lon_south = data->area_lon_south;
  __attribute__ ((aligned (32))) double area_lon_south[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_east+(ghy-hy), &area_lat_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_west+(ghy-hy), &area_lat_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_north+(ghy-hy), &area_lon_north[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_south+(ghy-hy), &area_lon_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = ((((1.0 - 0.5) * ((((((((area_lat_east[j+jb+oy] * pow(statev_lat[swindex[j]][(i - 1)],2)) + (area_lat_west[j+jb+oy] * pow(statev_lat[swindex[j]][i],2))) + (area_lon_north[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(stateu_lon[swindex[(j + 1)]][(i - 1)],2))) / area_vtx[j+jb+oy]) + (((((area_lat_east[j+jb+oy] * pow(statev_lat[swindex[j]][i],2)) + (area_lat_west[j+jb+oy] * pow(statev_lat[swindex[j]][(i + 1)],2))) + (area_lon_north[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(stateu_lon[swindex[(j + 1)]][i],2))) / area_vtx[j+jb+oy])) * area_subcell_1[j+jb+oy]) + (((((((area_lat_east[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][(i - 1)],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(stateu_lon[swindex[(j - 1)]][(i - 1)],2))) + (area_lon_south[j+jb+oy] * pow(stateu_lon[swindex[j]][(i - 1)],2))) / area_vtx[(j+jb+oy - 1)]) + (((((area_lat_east[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][i],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(statev_lat[swindex[(j - 1)]][(i + 1)],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(stateu_lon[swindex[(j - 1)]][i],2))) + (area_lon_south[j+jb+oy] * pow(stateu_lon[swindex[j]][i],2))) / area_vtx[(j+jb+oy - 1)])) * area_subcell_0[j+jb+oy]))) / area_cell[j+jb+oy]) + (0.5 * stateke[j][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_2_info *data = (calc_ke_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = pow(statev_lat[swindex[(j - 1)]][i],2);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_3_info *data = (calc_ke_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  double *_stateke = data->stateke;
  __attribute__ ((aligned (32))) double stateke[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateke[j][i] = (statetmpsum[swindex[j]][i] / 2400);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_2_0_info *data = (calc_vor_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statevor[j][i] = ((((stateu_lon[swindex[j]][i] * de_lon[j+jb+oy]) - (stateu_lon[swindex[(j + 1)]][i] * de_lon[(j+jb+oy + 1)])) + ((statev_lat[swindex[j]][(i + 1)] * de_lat[j+jb+oy]) - (statev_lat[swindex[j]][i] * de_lat[j+jb+oy]))) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_2_1_info *data = (calc_vor_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[8][256];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = (stateu_lat[swindex[j]][i] * le_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_2_2_info *data = (calc_vor_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[8][256];
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[8][256];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statevor[j][i] = ((statetmpsum[swindex[j]][i] / 2400) / area_cell[(j+jb+oy + 1)]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_pv_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_pv_2_0_info *data = (calc_pv_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statevor = data->statevor;
  __attribute__ ((aligned (32))) double statevor[12][260];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_half_f = data->half_f;
  __attribute__ ((aligned (32))) double half_f[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_f+(ghy-hy), &half_f[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &statevor[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &statem_vtx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &statevor[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &statem_vtx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statepv[j][i] = ((statevor[swindex[j]][i] + half_f[j+jb+oy]) / statem_vtx[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statepv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_2_0_info *data = (interp_pv_upwind_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lon = data->statev_lon;
  __attribute__ ((aligned (32))) double statev_lon[12][260];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_statepv_lon = data->statepv_lon;
  __attribute__ ((aligned (32))) double statepv_lon[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statev_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(statev_lon[swindex[j]][i]) / (sqrt((pow(stateu_lon[swindex[j]][i],2) + pow(statev_lon[swindex[j]][i],2))) + 1e-24));
            statepv_lon[j][i] = ((b * slave_upwind3(sign(1.0,statev_lon[swindex[j]][i]),1,statepv[swindex[(j - 2)]][i],statepv[swindex[(j - 1)]][i],statepv[swindex[j]][i],statepv[swindex[(j + 1)]][i])) + (((1 - b) * 0.5) * (statepv[swindex[(j - 1)]][i] + statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statepv_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_2_1_info *data = (interp_pv_upwind_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lat = data->stateu_lat;
  __attribute__ ((aligned (32))) double stateu_lat[12][260];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[12][260];
  
  double *_statepv = data->statepv;
  __attribute__ ((aligned (32))) double statepv[12][260];
  
  double *_statepv_lat = data->statepv_lat;
  __attribute__ ((aligned (32))) double statepv_lat[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &stateu_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(stateu_lat[swindex[j]][i]) / (sqrt((pow(stateu_lat[swindex[j]][i],2) + pow(statev_lat[swindex[j]][i],2))) + 1e-24));
            statepv_lat[j][i] = ((b * slave_upwind3(sign(1.0,stateu_lat[swindex[j]][i]),1,statepv[swindex[j]][(i - 2)],statepv[swindex[j]][(i - 1)],statepv[swindex[j]][i],statepv[swindex[j]][(i + 1)])) + (((1 - b) * 0.5) * (statepv[swindex[j]][(i - 1)] + statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statepv_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_2_0_info *data = (calc_div_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statediv = data->statediv;
  __attribute__ ((aligned (32))) double statediv[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statediv[j][i] = ((((stateu_lon[swindex[j]][i] * le_lon[j+jb+oy]) - (stateu_lon[swindex[j]][(i - 1)] * le_lon[j+jb+oy])) + ((statev_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (statev_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)]))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_2_1_info *data = (calc_div_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statetmpsum[j][i] = -statev_lat[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_2_2_info *data = (calc_div_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statetmpsum = data->statetmpsum;
  __attribute__ ((aligned (32))) double statetmpsum[10][258];
  
  double *_statediv = data->statediv;
  __attribute__ ((aligned (32))) double statediv[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statediv[j][i] = (((statetmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_gz_lev_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_gz_lev_2_0_info *data = (calc_gz_lev_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statet = data->statet;
  __attribute__ ((aligned (32))) double statet[bz+2*hz][bx+2*hx];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[bz+2*hz][bx+2*hx];
  
  double *_staticvgzs = data->staticvgzs;
  __attribute__ ((aligned (32))) double staticvgzs[bz+2*hz][bx+2*hx];
  
  double *_stategz_lev = data->stategz_lev;
  __attribute__ ((aligned (32))) double stategz_lev[bz+2*hz][bx+2*hx];
  
  double dgz;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_statet+(k*fnumy*fnumx+jb*fnumx+ib), &statet[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(jb*fnumx+ib), &staticvgzs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_statet+(k*fnumy*fnumx+jb*fnumx+ib), &statet[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(k*fnumy*fnumx+jb*fnumx+ib), &staticvgzs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            dgz = 0.0;
            for (l=k;l<((32 - 1) + 1)+ghz;l+=1){
              dgz = (dgz + ((287.04 * statet[swindex[l]][i]) * log((stateph_lev[swindex[(l + 1)]][i] / stateph_lev[swindex[l]][i]))));
            }
            stategz_lev[k][i] = (staticvgzs[swindex[0]][i] + dgz);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stategz_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void copy_old_m_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_2_0_info *data = (copy_old_m_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_advmold_m = data->advmold_m;
  __attribute__ ((aligned (32))) double advmold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmold_m[j][i] = statem[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void copy_old_m_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_2_1_info *data = (copy_old_m_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_advptold_m = data->advptold_m;
  __attribute__ ((aligned (32))) double advptold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptold_m[j][i] = statem[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}


void accum_uv_cell_2_45(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_45_info *data = (accum_uv_cell_2_45_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib), &advptu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = advptu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_46(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_46_info *data = (accum_uv_cell_2_46_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib), &advptv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = advptv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_47(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_47_info *data = (accum_uv_cell_2_47_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = star_stateu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_48(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_48_info *data = (accum_uv_cell_2_48_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = star_statev_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_49(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_49_info *data = (accum_uv_cell_2_49_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = ((advptuu[j][i] + star_stateu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_50(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_50_info *data = (accum_uv_cell_2_50_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = ((advptvv[j][i] + star_statev_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_51(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_51_info *data = (accum_uv_cell_2_51_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptu0 = data->advptu0;
  __attribute__ ((aligned (32))) double advptu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptu0[j][i] = advptuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_52(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_52_info *data = (accum_uv_cell_2_52_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptv0 = data->advptv0;
  __attribute__ ((aligned (32))) double advptv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptv0[j][i] = advptvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_53(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_53_info *data = (accum_uv_cell_2_53_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptuu[j][i] = (advptuu[j][i] + star_stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_54(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_54_info *data = (accum_uv_cell_2_54_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptvv[j][i] = (advptvv[j][i] + star_statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_55(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_55_info *data = (accum_uv_cell_2_55_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[8][258];
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflx[j][i] = ((advptuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_56(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_56_info *data = (accum_uv_cell_2_56_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcfly[j][i] = ((advptvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_57(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_57_info *data = (accum_uv_cell_2_57_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[10][258];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][258];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[10][258];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivx[j][i] = (((advptuu[swindex[j]][i] - advptuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advptdivy[j][i] = (((advptvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advptvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_58(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_58_info *data = (accum_uv_cell_2_58_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = -advptvv[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_59(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_59_info *data = (accum_uv_cell_2_59_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptdivy[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_12_info *data = (calc_mf_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfx_lon[j][i] = (star_statem_lon[swindex[j]][i] * star_stateu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statemfx_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_13_info *data = (calc_mf_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfy_lat[j][i] = (star_statem_lat[swindex[j]][i] * star_statev_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statemfy_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_18_info *data = (accum_mf_cell_2_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = star_statemfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_19_info *data = (accum_mf_cell_2_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = star_statemfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_20_info *data = (accum_mf_cell_2_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = ((advptmfx[j][i] + star_statemfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_21_info *data = (accum_mf_cell_2_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = ((advptmfy[j][i] + star_statemfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_22_info *data = (accum_mf_cell_2_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[10][258];
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfx[j][i] = (advptmfx[j][i] + star_statemfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_23_info *data = (accum_mf_cell_2_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][258];
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptmfy[j][i] = (advptmfy[j][i] + star_statemfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advptmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_14_info *data = (calc_mf_2_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_star_statemfx_lat = data->star_statemfx_lat;
  __attribute__ ((aligned (32))) double star_statemfx_lat[10][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[10][258];
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfx_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfx_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfx_lat[j][i] = ((half_tangent_wgt_0[j+jb+oy] * (star_statemfx_lon[swindex[j]][(i - 1)] + star_statemfx_lon[swindex[j]][i])) + (half_tangent_wgt_1[j+jb+oy] * (star_statemfx_lon[swindex[(j + 1)]][(i - 1)] + star_statemfx_lon[swindex[(j + 1)]][i])));
            star_stateu_lat[j][i] = (star_statemfx_lat[j][i] / star_statem_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfx_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statemfx_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateu_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_mf_2_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_mf_2_15_info *data = (calc_mf_2_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statemfy_lon = data->star_statemfy_lon;
  __attribute__ ((aligned (32))) double star_statemfy_lon[10][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[10][258];
  
  double *_star_statev_lon = data->star_statev_lon;
  __attribute__ ((aligned (32))) double star_statev_lon[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfy_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfy_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statemfy_lon[j][i] = ((full_tangent_wgt_0[j+jb+oy] * (star_statemfy_lat[swindex[(j - 1)]][i] + star_statemfy_lat[swindex[(j - 1)]][(i + 1)])) + (full_tangent_wgt_1[j+jb+oy] * (star_statemfy_lat[swindex[j]][i] + star_statemfy_lat[swindex[j]][(i + 1)])));
            star_statev_lon[j][i] = (star_statemfy_lon[j][i] / star_statem_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statemfy_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statemfy_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_12_info *data = (calc_ke_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = (((((area_lon_west[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2)) + (area_lon_east[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) + (area_lat_north[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2))) + (area_lat_south[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_13_info *data = (calc_ke_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_area_lat_east = data->area_lat_east;
  __attribute__ ((aligned (32))) double area_lat_east[hny+2*hy];
  
  double *_area_lat_west = data->area_lat_west;
  __attribute__ ((aligned (32))) double area_lat_west[hny+2*hy];
  
  double *_area_lon_north = data->area_lon_north;
  __attribute__ ((aligned (32))) double area_lon_north[fny+2*hy];
  
  double *_area_lon_south = data->area_lon_south;
  __attribute__ ((aligned (32))) double area_lon_south[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_east+(ghy-hy), &area_lat_east[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_west+(ghy-hy), &area_lat_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_north+(ghy-hy), &area_lon_north[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_south+(ghy-hy), &area_lon_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = ((((1.0 - 0.5) * ((((((((area_lat_east[j+jb+oy] * pow(star_statev_lat[swindex[j]][(i - 1)],2)) + (area_lat_west[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2))) + (area_lon_north[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(star_stateu_lon[swindex[(j + 1)]][(i - 1)],2))) / area_vtx[j+jb+oy]) + (((((area_lat_east[j+jb+oy] * pow(star_statev_lat[swindex[j]][i],2)) + (area_lat_west[j+jb+oy] * pow(star_statev_lat[swindex[j]][(i + 1)],2))) + (area_lon_north[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) + (area_lon_south[(j+jb+oy + 1)] * pow(star_stateu_lon[swindex[(j + 1)]][i],2))) / area_vtx[j+jb+oy])) * area_subcell_1[j+jb+oy]) + (((((((area_lat_east[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][(i - 1)],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(star_stateu_lon[swindex[(j - 1)]][(i - 1)],2))) + (area_lon_south[j+jb+oy] * pow(star_stateu_lon[swindex[j]][(i - 1)],2))) / area_vtx[(j+jb+oy - 1)]) + (((((area_lat_east[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][i],2)) + (area_lat_west[(j+jb+oy - 1)] * pow(star_statev_lat[swindex[(j - 1)]][(i + 1)],2))) + (area_lon_north[(j+jb+oy - 1)] * pow(star_stateu_lon[swindex[(j - 1)]][i],2))) + (area_lon_south[j+jb+oy] * pow(star_stateu_lon[swindex[j]][i],2))) / area_vtx[(j+jb+oy - 1)])) * area_subcell_0[j+jb+oy]))) / area_cell[j+jb+oy]) + (0.5 * star_stateke[j][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_14_info *data = (calc_ke_2_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = pow(star_statev_lat[swindex[(j - 1)]][i],2);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ke_2_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ke_2_15_info *data = (calc_ke_2_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_stateke[j][i] = (star_statetmpsum[swindex[j]][i] / 2400);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateke[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_2_9_info *data = (calc_div_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statediv = data->star_statediv;
  __attribute__ ((aligned (32))) double star_statediv[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statediv[j][i] = ((((star_stateu_lon[swindex[j]][i] * le_lon[j+jb+oy]) - (star_stateu_lon[swindex[j]][(i - 1)] * le_lon[j+jb+oy])) + ((star_statev_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_statev_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)]))) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_2_10_info *data = (calc_div_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = -star_statev_lat[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_div_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_div_2_11_info *data = (calc_div_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  double *_star_statediv = data->star_statediv;
  __attribute__ ((aligned (32))) double star_statediv[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statediv[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statediv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statediv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_2_9_info *data = (calc_vor_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[10][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[10][258];
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statevor[j][i] = ((((star_stateu_lon[swindex[j]][i] * de_lon[j+jb+oy]) - (star_stateu_lon[swindex[(j + 1)]][i] * de_lon[(j+jb+oy + 1)])) + ((star_statev_lat[swindex[j]][(i + 1)] * de_lat[j+jb+oy]) - (star_statev_lat[swindex[j]][i] * de_lat[j+jb+oy]))) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_2_10_info *data = (calc_vor_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[8][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = (star_stateu_lat[swindex[j]][i] * le_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_vor_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_vor_2_11_info *data = (calc_vor_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[8][256];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statevor[j][i] = ((star_statetmpsum[swindex[j]][i] / 2400) / area_cell[(j+jb+oy + 1)]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statevor[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_pv_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_pv_2_3_info *data = (calc_pv_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statevor = data->star_statevor;
  __attribute__ ((aligned (32))) double star_statevor[12][260];
  
  double *_star_statem_vtx = data->star_statem_vtx;
  __attribute__ ((aligned (32))) double star_statem_vtx[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_half_f = data->half_f;
  __attribute__ ((aligned (32))) double half_f[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_f+(ghy-hy), &half_f[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &star_statevor[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_vtx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statevor+(kb*hnumy*hnumx+j*hnumx+ib), &star_statevor[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib), &star_statem_vtx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statepv[j][i] = ((star_statevor[swindex[j]][i] + half_f[j+jb+oy]) / star_statem_vtx[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statepv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_2_6_info *data = (interp_pv_upwind_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statev_lon = data->star_statev_lon;
  __attribute__ ((aligned (32))) double star_statev_lon[12][260];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statev_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statev_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(star_statev_lon[swindex[j]][i]) / (sqrt((pow(star_stateu_lon[swindex[j]][i],2) + pow(star_statev_lon[swindex[j]][i],2))) + 1e-24));
            star_statepv_lon[j][i] = ((b * slave_upwind3(sign(1.0,star_statev_lon[swindex[j]][i]),1,star_statepv[swindex[(j - 2)]][i],star_statepv[swindex[(j - 1)]][i],star_statepv[swindex[j]][i],star_statepv[swindex[(j + 1)]][i])) + (((1 - b) * 0.5) * (star_statepv[swindex[(j - 1)]][i] + star_statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statepv_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_pv_upwind_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_pv_upwind_2_7_info *data = (interp_pv_upwind_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateu_lat = data->star_stateu_lat;
  __attribute__ ((aligned (32))) double star_stateu_lat[12][260];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[12][260];
  
  double *_star_statepv = data->star_statepv;
  __attribute__ ((aligned (32))) double star_statepv[12][260];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[12][260];
  
  double b;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateu_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateu_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            b = (fabs(star_stateu_lat[swindex[j]][i]) / (sqrt((pow(star_stateu_lat[swindex[j]][i],2) + pow(star_statev_lat[swindex[j]][i],2))) + 1e-24));
            star_statepv_lat[j][i] = ((b * slave_upwind3(sign(1.0,star_stateu_lat[swindex[j]][i]),1,star_statepv[swindex[j]][(i - 2)],star_statepv[swindex[j]][(i - 1)],star_statepv[swindex[j]][i],star_statepv[swindex[j]][(i + 1)])) + (((1 - b) * 0.5) * (star_statepv[swindex[j]][(i - 1)] + star_statepv[swindex[j]][i])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statepv_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_2_8_info *data = (calc_grad_mf_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_tend1dmfdlon = data->tend1dmfdlon;
  __attribute__ ((aligned (32))) double tend1dmfdlon[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlon[j][i] = (((star_statemfx_lon[swindex[j]][i] - star_statemfx_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_2_9_info *data = (calc_grad_mf_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlat[j][i] = (((star_statemfy_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_statemfy_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_2_10_info *data = (calc_grad_mf_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = -star_statemfy_lat[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_mf_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_mf_2_11_info *data = (calc_grad_mf_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dmfdlat[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dmfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dmfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_we_lev_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_we_lev_2_2_info *data = (calc_we_lev_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dmfdlon = data->tend1dmfdlon;
  __attribute__ ((aligned (32))) double tend1dmfdlon[bz+2*hz][bx+2*hx];
  
  double *_tend1dmfdlat = data->tend1dmfdlat;
  __attribute__ ((aligned (32))) double tend1dmfdlat[bz+2*hz][bx+2*hx];
  
  double *_tend1dphs = data->tend1dphs;
  __attribute__ ((aligned (32))) double tend1dphs[bz+2*hz][bx+2*hx];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[bz+2*hz][bx+2*hx];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  double mfs;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_tend1dmfdlon+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dmfdlat+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dphs+(jb*fnumx+ib), &tend1dphs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_tend1dmfdlon+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dmfdlat+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dmfdlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dphs+(k*fnumy*fnumx+jb*fnumx+ib), &tend1dphs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            mfs = 0.0;
            for (l=0+ghz;l<((k - 1) + 1);l+=1){
              mfs = ((mfs + tend1dmfdlon[swindex[l]][i]) + tend1dmfdlat[swindex[l]][i]);
            }
            star_statewe_lev[k][i] = (-slave_hybrid_coord_calc_dphdt_lev(hybi[k+kb+oz],tend1dphs[swindex[0]][i]) - mfs);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_statewe_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_statewe_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_10_info *data = (accum_we_lev_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe0 = data->advptwe0;
  __attribute__ ((aligned (32))) double advptwe0[8][256];
  
  double *_advptm0 = data->advptm0;
  __attribute__ ((aligned (32))) double advptm0[8][256];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[8][256];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe0[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib), &advptm0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe0[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib), &advptm0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = advptwe0[j][i];
            advptmm[j][i] = advptm0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_11_info *data = (accum_we_lev_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = star_statewe_lev[swindex[j]][i];
            advptmm[j][i] = star_statem_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_12_info *data = (accum_we_lev_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  double *_advptwe0 = data->advptwe0;
  __attribute__ ((aligned (32))) double advptwe0[10][258];
  
  double *_advptm0 = data->advptm0;
  __attribute__ ((aligned (32))) double advptm0[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = ((advptwe[j][i] + star_statewe_lev[swindex[j]][i]) / ((nstep) + 1));
            advptmm[j][i] = ((advptmm[j][i] + star_statem_lev[swindex[j]][i]) / ((nstep) + 1));
            advptwe0[j][i] = star_statewe_lev[swindex[j]][i];
            advptm0[j][i] = star_statem_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptwe0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptm0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptm0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_13_info *data = (accum_we_lev_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[10][258];
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[10][258];
  
  double *_star_statem_lev = data->star_statem_lev;
  __attribute__ ((aligned (32))) double star_statem_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statem_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptwe[j][i] = (advptwe[j][i] + star_statewe_lev[swindex[j]][i]);
            advptmm[j][i] = (advptmm[j][i] + star_statem_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_14_info *data = (accum_we_lev_2_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[8][256];
  
  double *_advptmm = data->advptmm;
  __attribute__ ((aligned (32))) double advptmm[8][256];
  
  double *_advptcflz = data->advptcflz;
  __attribute__ ((aligned (32))) double advptcflz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptwe+(kb*fnumy*fnumx+j*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmm+(kb*fnumy*fnumx+j*fnumx+ib), &advptmm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptcflz[j][i] = ((advptwe[swindex[j]][i] / advptmm[swindex[j]][i]) * dt);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptcflz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptcflz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_lev_edge_to_lev_lon_edge_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_lev_edge_to_lev_lon_edge_2_2_info *data = (interp_lev_edge_to_lev_lon_edge_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[10][258];
  
  double *_area_lon_west = data->area_lon_west;
  __attribute__ ((aligned (32))) double area_lon_west[fny+2*hy];
  
  double *_area_lon_east = data->area_lon_east;
  __attribute__ ((aligned (32))) double area_lon_east[fny+2*hy];
  
  double *_area_lon = data->area_lon;
  __attribute__ ((aligned (32))) double area_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_west+(ghy-hy), &area_lon_west[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon_east+(ghy-hy), &area_lon_east[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_lon+(ghy-hy), &area_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statewe_lev_lon[j][i] = (((area_lon_west[j+jb+oy] * star_statewe_lev[swindex[j]][i]) + (area_lon_east[j+jb+oy] * star_statewe_lev[swindex[j]][(i + 1)])) / area_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statewe_lev_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statewe_lev_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interp_lev_edge_to_lev_lat_edge_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interp_lev_edge_to_lev_lat_edge_2_2_info *data = (interp_lev_edge_to_lev_lat_edge_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev = data->star_statewe_lev;
  __attribute__ ((aligned (32))) double star_statewe_lev[10][258];
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[10][258];
  
  double *_area_lat_north = data->area_lat_north;
  __attribute__ ((aligned (32))) double area_lat_north[hny+2*hy];
  
  double *_area_lat_south = data->area_lat_south;
  __attribute__ ((aligned (32))) double area_lat_south[hny+2*hy];
  
  double *_area_lat = data->area_lat;
  __attribute__ ((aligned (32))) double area_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_north+(ghy-hy), &area_lat_north[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat_south+(ghy-hy), &area_lat_south[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_lat+(ghy-hy), &area_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statewe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &star_statewe_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statewe_lev_lat[j][i] = (((area_lat_north[j+jb+oy] * star_statewe_lev[swindex[(j + 1)]][i]) + (area_lat_south[j+jb+oy] * star_statewe_lev[swindex[j]][i])) / area_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statewe_lev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_statewe_lev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_2_8_info *data = (calc_wedudlev_wedvdlev_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[6][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[6][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[6][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedudlev[k][i] = ((((star_statewe_lev_lon[swindex[(k + 1)]][i] * (star_stateu_lon[swindex[(k + 1)]][i] - star_stateu_lon[swindex[k]][i])) + (star_statewe_lev_lon[swindex[k]][i] * (star_stateu_lon[swindex[k]][i] - star_stateu_lon[swindex[(k - 1)]][i]))) / star_statem_lon[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedudlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1wedudlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_2_9_info *data = (calc_wedudlev_wedvdlev_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lon = data->star_statewe_lev_lon;
  __attribute__ ((aligned (32))) double star_statewe_lev_lon[6][258];
  
  double *_star_stateu_lon = data->star_stateu_lon;
  __attribute__ ((aligned (32))) double star_stateu_lon[6][258];
  
  double *_star_statem_lon = data->star_statem_lon;
  __attribute__ ((aligned (32))) double star_statem_lon[6][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statewe_lev_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateu_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lon+(k*fnumy*fnumx+jb*fnumx+ib), &star_statem_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedudlev[k][i] = (((star_statewe_lev_lon[swindex[k]][i] * (star_stateu_lon[swindex[k]][i] - star_stateu_lon[swindex[(k - 1)]][i])) / star_statem_lon[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedudlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1wedudlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_2_10_info *data = (calc_wedudlev_wedvdlev_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[6][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[6][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[6][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedvdlev[k][i] = ((((star_statewe_lev_lat[swindex[(k + 1)]][i] * (star_statev_lat[swindex[(k + 1)]][i] - star_statev_lat[swindex[k]][i])) + (star_statewe_lev_lat[swindex[k]][i] * (star_statev_lat[swindex[k]][i] - star_statev_lat[swindex[(k - 1)]][i]))) / star_statem_lat[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedvdlev+(k*hnumy*hnumx+jb*hnumx+ib+hx), &tend1wedvdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_wedudlev_wedvdlev_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_wedudlev_wedvdlev_2_11_info *data = (calc_wedudlev_wedvdlev_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statewe_lev_lat = data->star_statewe_lev_lat;
  __attribute__ ((aligned (32))) double star_statewe_lev_lat[6][258];
  
  double *_star_statev_lat = data->star_statev_lat;
  __attribute__ ((aligned (32))) double star_statev_lat[6][258];
  
  double *_star_statem_lat = data->star_statem_lat;
  __attribute__ ((aligned (32))) double star_statem_lat[6][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statewe_lev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statewe_lev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statev_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statem_lat+(k*hnumy*hnumx+jb*hnumx+ib), &star_statem_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1wedvdlev[k][i] = (((star_statewe_lev_lat[swindex[k]][i] * (star_statev_lat[swindex[k]][i] - star_statev_lat[swindex[(k - 1)]][i])) / star_statem_lat[swindex[k]][i]) / 2.0);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1wedvdlev+(k*hnumy*hnumx+jb*hnumx+ib+hx), &tend1wedvdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_2_6_info *data = (hflx_ppm_inner_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[12][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[12][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[12][260];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[12][260];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[12][260];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(star_statept[swindex[j]][(i - 2)],star_statept[swindex[j]][(i - 1)],star_statept[swindex[j]][i],star_statept[swindex[j]][(i + 1)],star_statept[swindex[j]][(i + 2)]);
            advptqlx[j][i] = buf.x;
            advptdqx[j][i] = buf.y;
            advptq6x[j][i] = buf.z;
            buf = slave_ppm(star_statept[swindex[(j - 2)]][i],star_statept[swindex[(j - 1)]][i],star_statept[swindex[j]][i],star_statept[swindex[(j + 1)]][i],star_statept[swindex[(j + 2)]][i]);
            advptqly[j][i] = buf.x;
            advptdqy[j][i] = buf.y;
            advptq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_2_7_info *data = (hflx_ppm_inner_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[by+2*hy][bx+2*hx];
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[by+2*hy][bx+2*hx];
  
  double *_advptuu = data->advptuu;
  __attribute__ ((aligned (32))) double advptuu[by+2*hy][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[by+2*hy][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[by+2*hy][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[by+2*hy][bx+2*hx];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptuu+(kb*fnumy*fnumx+j*fnumx+ib), &advptuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflx[swindex[j]][i]);
            cf = (advptcflx[swindex[j]][i] - ci);
            if ((advptcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + star_statept[swindex[j]][l]);
              }
              star_stateptf_lon[j][i] = ((advptuu[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advptdqx[swindex[j]][(i - ci)]) * ds2)) + (advptq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
            }
            else
            {
              if ((advptcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + star_statept[swindex[j]][l]);
                }
                star_stateptf_lon[j][i] = ((-advptuu[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advptdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advptq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateptf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_2_8_info *data = (hflx_ppm_inner_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_advptvv = data->advptvv;
  __attribute__ ((aligned (32))) double advptvv[10][256];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[10][256];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[10][256];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[10][256];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptvv+(kb*hnumy*hnumx+j*hnumx+ib), &advptvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advptcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advptcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              star_stateptf_lat[j][i] = ((advptvv[swindex[j]][i] * (((advptqly[swindex[j]][i] * ds1) + ((0.5 * advptdqy[swindex[j]][i]) * ds2)) + (advptq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
            }
            else
            {
              if ((advptcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advptcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                star_stateptf_lat[j][i] = ((-advptvv[swindex[j]][i] * (((advptqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advptdqy[swindex[(j + 1)]][i]) * ds2)) + (advptq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateptf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_2_6_info *data = (ffsl_calc_tracer_hflx_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[12][260];
  
  double *_advptdivx = data->advptdivx;
  __attribute__ ((aligned (32))) double advptdivx[12][260];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[12][260];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptqx[j][i] = (star_statept[swindex[j]][i] - ((0.5 * ((((star_stateptf_lon[swindex[j]][i] - star_stateptf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]) - (advptdivx[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
            advptqy[j][i] = (star_statept[swindex[j]][i] - ((0.5 * ((((star_stateptf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_stateptf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) - (advptdivy[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_2_7_info *data = (ffsl_calc_tracer_hflx_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = star_stateptf_lat[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_2_8_info *data = (ffsl_calc_tracer_hflx_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[12][260];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[12][260];
  
  double *_advptdivy = data->advptdivy;
  __attribute__ ((aligned (32))) double advptdivy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statept+(kb*fnumy*fnumx+j*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advptqx[j][i] = star_statept[swindex[j]][i];
            advptqy[j][i] = (star_statept[swindex[j]][i] + ((0.5 * ((((star_statetmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]) - (advptdivy[swindex[j]][i] * star_statept[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_2_6_info *data = (hflx_ppm_outer_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[12][260];
  
  double *_advptqx = data->advptqx;
  __attribute__ ((aligned (32))) double advptqx[12][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[12][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[12][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[12][260];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[12][260];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[12][260];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(advptqy[swindex[j]][(i - 2)],advptqy[swindex[j]][(i - 1)],advptqy[swindex[j]][i],advptqy[swindex[j]][(i + 1)],advptqy[swindex[j]][(i + 2)]);
            advptqlx[j][i] = buf.x;
            advptdqx[j][i] = buf.y;
            advptq6x[j][i] = buf.z;
            buf = slave_ppm(advptqx[swindex[(j - 2)]][i],advptqx[swindex[(j - 1)]][i],advptqx[swindex[j]][i],advptqx[swindex[(j + 1)]][i],advptqx[swindex[(j + 2)]][i]);
            advptqly[j][i] = buf.x;
            advptdqy[j][i] = buf.y;
            advptq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advptq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_2_7_info *data = (hflx_ppm_outer_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflx = data->advptcflx;
  __attribute__ ((aligned (32))) double advptcflx[by+2*hy][bx+2*hx];
  
  double *_advptqy = data->advptqy;
  __attribute__ ((aligned (32))) double advptqy[by+2*hy][bx+2*hx];
  
  double *_advptmfx = data->advptmfx;
  __attribute__ ((aligned (32))) double advptmfx[by+2*hy][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[by+2*hy][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[by+2*hy][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[by+2*hy][bx+2*hx];
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advptcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advptmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflx[swindex[j]][i]);
            cf = (advptcflx[swindex[j]][i] - ci);
            if ((advptcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + advptqy[swindex[j]][l]);
              }
              star_stateptf_lon[j][i] = ((advptmfx[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advptdqx[swindex[j]][(i - ci)]) * ds2)) + (advptq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
            }
            else
            {
              if ((advptcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + advptqy[swindex[j]][l]);
                }
                star_stateptf_lon[j][i] = ((-advptmfx[swindex[j]][i] * (((cursum + (advptqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advptdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advptq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflx[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_stateptf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_2_8_info *data = (hflx_ppm_outer_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcfly = data->advptcfly;
  __attribute__ ((aligned (32))) double advptcfly[10][256];
  
  double *_advptmfy = data->advptmfy;
  __attribute__ ((aligned (32))) double advptmfy[10][256];
  
  double *_advptqly = data->advptqly;
  __attribute__ ((aligned (32))) double advptqly[10][256];
  
  double *_advptdqy = data->advptdqy;
  __attribute__ ((aligned (32))) double advptdqy[10][256];
  
  double *_advptq6y = data->advptq6y;
  __attribute__ ((aligned (32))) double advptq6y[10][256];
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advptcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advptcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advptmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqly+(kb*fnumy*fnumx+j*fnumx+ib), &advptqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advptdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advptq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advptcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advptcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              star_stateptf_lat[j][i] = ((advptmfy[swindex[j]][i] * (((advptqly[swindex[j]][i] * ds1) + ((0.5 * advptdqy[swindex[j]][i]) * ds2)) + (advptq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
            }
            else
            {
              if ((advptcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advptcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                star_stateptf_lat[j][i] = ((-advptmfy[swindex[j]][i] * (((advptqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advptdqy[swindex[(j + 1)]][i]) * ds2)) + (advptq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcfly[swindex[j]][i]);
              }
              else
              {
                star_stateptf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &star_stateptf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_2_12_info *data = (calc_grad_ptf_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lon = data->star_stateptf_lon;
  __attribute__ ((aligned (32))) double star_stateptf_lon[8][258];
  
  double *_tend1dptfdlon = data->tend1dptfdlon;
  __attribute__ ((aligned (32))) double tend1dptfdlon[8][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateptf_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlon[j][i] = (((star_stateptf_lon[swindex[j]][i] - star_stateptf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_2_13_info *data = (calc_grad_ptf_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[10][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlat[j][i] = (((star_stateptf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (star_stateptf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_2_14(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_2_14_info *data = (calc_grad_ptf_2_14_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lat = data->star_stateptf_lat;
  __attribute__ ((aligned (32))) double star_stateptf_lat[10][256];
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateptf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_stateptf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            star_statetmpsum[j][i] = -star_stateptf_lat[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &star_statetmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_2_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_2_15_info *data = (calc_grad_ptf_2_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statetmpsum = data->star_statetmpsum;
  __attribute__ ((aligned (32))) double star_statetmpsum[8][256];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statetmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &star_statetmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlat[j][i] = (((star_statetmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dptfdlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_2_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_2_16_info *data = (calc_grad_ptf_2_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[8][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            star_statept[k][i] = ((2 * star_statept[(k - 1)][i]) - star_statept[(k - 2)][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_statept[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_2_4_info *data = (vflx_ppm_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[8][260];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[8][260];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[8][260];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[8][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(star_statept[swindex[(k - 2)]][i],star_statept[swindex[(k - 1)]][i],star_statept[swindex[k]][i],star_statept[swindex[(k + 1)]][i],star_statept[swindex[(k + 2)]][i]);
            advptqlx[k][i] = buf.x;
            advptdqx[k][i] = buf.y;
            advptq6x[k][i] = buf.z;
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptqlx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptdqx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advptq6x[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_2_5_info *data = (vflx_ppm_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advptcflz = data->advptcflz;
  __attribute__ ((aligned (32))) double advptcflz[bz+2*hz][bx+2*hx];
  
  double *_star_statept = data->star_statept;
  __attribute__ ((aligned (32))) double star_statept[bz+2*hz][bx+2*hx];
  
  double *_advptwe = data->advptwe;
  __attribute__ ((aligned (32))) double advptwe[bz+2*hz][bx+2*hx];
  
  double *_advptqlx = data->advptqlx;
  __attribute__ ((aligned (32))) double advptqlx[bz+2*hz][bx+2*hx];
  
  double *_advptdqx = data->advptdqx;
  __attribute__ ((aligned (32))) double advptdqx[bz+2*hz][bx+2*hx];
  
  double *_advptq6x = data->advptq6x;
  __attribute__ ((aligned (32))) double advptq6x[bz+2*hz][bx+2*hx];
  
  double *_star_stateptf_lev = data->star_stateptf_lev;
  __attribute__ ((aligned (32))) double star_stateptf_lev[bz+2*hz][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_advptcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advptcflz[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptwe+(k*fnumy*fnumx+jb*fnumx+ib), &advptwe[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advptqlx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advptdqx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advptq6x[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_advptcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advptcflz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statept+(k*fnumy*fnumx+jb*fnumx+ib), &star_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptwe+(k*fnumy*fnumx+jb*fnumx+ib), &advptwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advptqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advptdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advptq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advptq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advptcflz[swindex[k]][i]);
            cf = (advptcflz[swindex[k]][i] - ci);
            if ((advptcflz[swindex[k]][i] > 0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=(k - ci);l<((k - 1) + 1);l+=1){
                cursum = (cursum + star_statept[swindex[l]][i]);
              }
              star_stateptf_lev[k][i] = ((advptwe[swindex[k]][i] * (((cursum + (advptqlx[swindex[((k - ci) - 1)]][i] * ds1)) + ((0.5 * advptdqx[swindex[((k - ci) - 1)]][i]) * ds2)) + (advptq6x[swindex[((k - ci) - 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflz[swindex[k]][i]);
            }
            else
            {
              if ((advptcflz[swindex[k]][i] < 0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                for (l=k;l<(((k - ci) - 1) + 1);l+=1){
                  cursum = (cursum + star_statept[swindex[l]][i]);
                }
                star_stateptf_lev[k][i] = ((-advptwe[swindex[k]][i] * (((cursum + (advptqlx[swindex[(k - ci)]][i] * ds1)) + ((0.5 * advptdqx[swindex[(k - ci)]][i]) * ds2)) + (advptq6x[swindex[(k - ci)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advptcflz[swindex[k]][i]);
              }
              else
              {
                star_stateptf_lev[k][i] = 0.0;
              }
            }
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &star_stateptf_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ptf_2_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ptf_2_17_info *data = (calc_grad_ptf_2_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateptf_lev = data->star_stateptf_lev;
  __attribute__ ((aligned (32))) double star_stateptf_lev[6][256];
  
  double *_tend1dptfdlev = data->tend1dptfdlev;
  __attribute__ ((aligned (32))) double tend1dptfdlev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateptf_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_star_stateptf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &star_stateptf_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dptfdlev[k][i] = (star_stateptf_lev[swindex[(k + 1)]][i] - star_stateptf_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend1dptfdlev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend1dptfdlev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_coriolis_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_coriolis_2_4_info *data = (calc_coriolis_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfx_lon = data->star_statemfx_lon;
  __attribute__ ((aligned (32))) double star_statemfx_lon[10][258];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[10][258];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[10][258];
  
  double *_tend1qhu = data->tend1qhu;
  __attribute__ ((aligned (32))) double tend1qhu[10][258];
  
  double *_half_tangent_wgt_0 = data->half_tangent_wgt_0;
  __attribute__ ((aligned (32))) double half_tangent_wgt_0[hny+2*hy];
  
  double *_half_tangent_wgt_1 = data->half_tangent_wgt_1;
  __attribute__ ((aligned (32))) double half_tangent_wgt_1[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_0+(ghy-hy), &half_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_tangent_wgt_1+(ghy-hy), &half_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statemfx_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1qhu[j][i] = (((half_tangent_wgt_0[j+jb+oy] * ((star_statemfx_lon[swindex[j]][(i - 1)] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[j]][(i - 1)])) + (star_statemfx_lon[swindex[j]][i] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[j]][i])))) + (half_tangent_wgt_1[j+jb+oy] * ((star_statemfx_lon[swindex[(j + 1)]][(i - 1)] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[(j + 1)]][(i - 1)])) + (star_statemfx_lon[swindex[(j + 1)]][i] * (star_statepv_lat[swindex[j]][i] + star_statepv_lon[swindex[(j + 1)]][i]))))) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1qhu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_coriolis_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_coriolis_2_5_info *data = (calc_coriolis_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_statemfy_lat = data->star_statemfy_lat;
  __attribute__ ((aligned (32))) double star_statemfy_lat[10][258];
  
  double *_star_statepv_lon = data->star_statepv_lon;
  __attribute__ ((aligned (32))) double star_statepv_lon[10][258];
  
  double *_star_statepv_lat = data->star_statepv_lat;
  __attribute__ ((aligned (32))) double star_statepv_lat[10][258];
  
  double *_tend1qhv = data->tend1qhv;
  __attribute__ ((aligned (32))) double tend1qhv[10][258];
  
  double *_full_tangent_wgt_0 = data->full_tangent_wgt_0;
  __attribute__ ((aligned (32))) double full_tangent_wgt_0[fny+2*hy];
  
  double *_full_tangent_wgt_1 = data->full_tangent_wgt_1;
  __attribute__ ((aligned (32))) double full_tangent_wgt_1[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_0+(ghy-hy), &full_tangent_wgt_0[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_tangent_wgt_1+(ghy-hy), &full_tangent_wgt_1[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_statemfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statemfy_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lon+(kb*fnumy*fnumx+j*fnumx+ib), &star_statepv_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_star_statepv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &star_statepv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1qhv[j][i] = (((full_tangent_wgt_0[j+jb+oy] * ((star_statemfy_lat[swindex[(j - 1)]][i] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[(j - 1)]][i])) + (star_statemfy_lat[swindex[(j - 1)]][(i + 1)] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[(j - 1)]][(i + 1)])))) + (full_tangent_wgt_1[j+jb+oy] * ((star_statemfy_lat[swindex[j]][i] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[j]][i])) + (star_statemfy_lat[swindex[j]][(i + 1)] * (star_statepv_lon[swindex[j]][i] + star_statepv_lat[swindex[j]][(i + 1)]))))) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1qhv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ke_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ke_2_4_info *data = (calc_grad_ke_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_tend1dkedlon = data->tend1dkedlon;
  __attribute__ ((aligned (32))) double tend1dkedlon[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dkedlon[j][i] = ((star_stateke[swindex[j]][(i + 1)] - star_stateke[swindex[j]][i]) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dkedlon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_grad_ke_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_grad_ke_2_5_info *data = (calc_grad_ke_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_star_stateke = data->star_stateke;
  __attribute__ ((aligned (32))) double star_stateke[10][258];
  
  double *_tend1dkedlat = data->tend1dkedlat;
  __attribute__ ((aligned (32))) double tend1dkedlat[10][258];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_star_stateke+(kb*fnumy*fnumx+j*fnumx+ib), &star_stateke[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dkedlat[j][i] = ((star_stateke[swindex[(j + 1)]][i] - star_stateke[swindex[j]][i]) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1dkedlat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_2_6_info *data = (calc_tend_forward_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1qhv = data->tend1qhv;
  __attribute__ ((aligned (32))) double tend1qhv[10][258];
  
  double *_tend1dkedlon = data->tend1dkedlon;
  __attribute__ ((aligned (32))) double tend1dkedlon[10][258];
  
  double *_tend1wedudlev = data->tend1wedudlev;
  __attribute__ ((aligned (32))) double tend1wedudlev[10][258];
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib), &tend1qhv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dkedlon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedudlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1wedudlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1qhv+(kb*fnumy*fnumx+j*fnumx+ib), &tend1qhv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dkedlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedudlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1wedudlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1du[j][i] = ((tend1qhv[swindex[j]][i] - tend1dkedlon[swindex[j]][i]) - tend1wedudlev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1du[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_2_7_info *data = (calc_tend_forward_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1qhu = data->tend1qhu;
  __attribute__ ((aligned (32))) double tend1qhu[10][258];
  
  double *_tend1dkedlat = data->tend1dkedlat;
  __attribute__ ((aligned (32))) double tend1dkedlat[10][258];
  
  double *_tend1wedvdlev = data->tend1wedvdlev;
  __attribute__ ((aligned (32))) double tend1wedvdlev[10][258];
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib), &tend1qhu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dkedlat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedvdlev+(kb*hnumy*hnumx+j*hnumx+ib), &tend1wedvdlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1qhu+(kb*hnumy*hnumx+j*hnumx+ib), &tend1qhu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dkedlat+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dkedlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1wedvdlev+(kb*hnumy*hnumx+j*hnumx+ib), &tend1wedvdlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dv[j][i] = ((-tend1qhu[swindex[j]][i] - tend1dkedlat[swindex[j]][i]) - tend1wedvdlev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend1dv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_forward_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_forward_2_8_info *data = (calc_tend_forward_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dptfdlon = data->tend1dptfdlon;
  __attribute__ ((aligned (32))) double tend1dptfdlon[10][258];
  
  double *_tend1dptfdlat = data->tend1dptfdlat;
  __attribute__ ((aligned (32))) double tend1dptfdlat[10][258];
  
  double *_tend1dptfdlev = data->tend1dptfdlev;
  __attribute__ ((aligned (32))) double tend1dptfdlev[10][258];
  
  double *_tend1dpt = data->tend1dpt;
  __attribute__ ((aligned (32))) double tend1dpt[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1dptfdlon+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlat+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dptfdlev+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dptfdlev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend1dpt[j][i] = ((-tend1dptfdlon[j][i] - tend1dptfdlat[j][i]) - tend1dptfdlev[j][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend1dpt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_15_info *data = (calc_ph_2_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statephs = data->new_statephs;
  __attribute__ ((aligned (32))) double new_statephs[10][258];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],new_statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_16_info *data = (calc_ph_2_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_exn_lev[j][i] = pow(new_stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_17_info *data = (calc_ph_2_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph[k][i] = (0.5 * (new_stateph_lev[k][i] + new_stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_36(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_36_info *data = (calc_m_2_36_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_37(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_37_info *data = (calc_m_2_37_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_38(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_38_info *data = (calc_m_2_38_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_39(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_39_info *data = (calc_m_2_39_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_2_9_info *data = (averageCellToLonEdge_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_2_9_info *data = (averageCellToLatEdge_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_2_9_info *data = (interpCellToVtx_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_16_info *data = (update_state_2_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statept = data->old_statept;
  __attribute__ ((aligned (32))) double old_statept[12][260];
  
  double *_old_statem = data->old_statem;
  __attribute__ ((aligned (32))) double old_statem[12][260];
  
  double *_tend1dpt = data->tend1dpt;
  __attribute__ ((aligned (32))) double tend1dpt[12][260];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[12][260];
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dpt[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dpt[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statept[j][i] = (((old_statept[swindex[j]][i] * old_statem[swindex[j]][i]) + (dt * tend1dpt[swindex[j]][i])) / new_statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_17_info *data = (update_state_2_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stategz = data->old_stategz;
  __attribute__ ((aligned (32))) double old_stategz[8][256];
  
  double *_tend1dgz = data->tend1dgz;
  __attribute__ ((aligned (32))) double tend1dgz[8][256];
  
  double *_new_stategz = data->new_stategz;
  __attribute__ ((aligned (32))) double new_stategz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dgz[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend1dgz[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stategz[j][i] = (old_stategz[swindex[j]][i] + (dt * tend1dgz[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stategz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stategz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_40(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_40_info *data = (calc_m_2_40_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_41(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_41_info *data = (calc_m_2_41_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_42(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_42_info *data = (calc_m_2_42_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_43(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_43_info *data = (calc_m_2_43_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_2_10_info *data = (averageCellToLonEdge_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_2_10_info *data = (averageCellToLatEdge_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_2_10_info *data = (interpCellToVtx_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_18_info *data = (update_state_2_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stateu_lon = data->old_stateu_lon;
  __attribute__ ((aligned (32))) double old_stateu_lon[10][258];
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  double *_new_stateu_lon = data->new_stateu_lon;
  __attribute__ ((aligned (32))) double new_stateu_lon[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateu_lon[j][i] = (old_stateu_lon[swindex[j]][i] + (dt * tend1du[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_19_info *data = (update_state_2_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statev_lat = data->old_statev_lat;
  __attribute__ ((aligned (32))) double old_statev_lat[10][258];
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  double *_new_statev_lat = data->new_statev_lat;
  __attribute__ ((aligned (32))) double new_statev_lat[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statev_lat[j][i] = (old_statev_lat[swindex[j]][i] + (dt * tend1dv[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_t_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_t_2_3_info *data = (calc_t_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[12][260];
  
  double *_new_stateqv = data->new_stateqv;
  __attribute__ ((aligned (32))) double new_stateqv[12][260];
  
  double *_new_statet = data->new_statet;
  __attribute__ ((aligned (32))) double new_statet[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib), &new_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib), &new_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateqv+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statet[j][i] = slave_temperature(new_statept[swindex[j]][i],new_stateph[swindex[j]][i],new_stateqv[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statet+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statet[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_gz_lev_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_gz_lev_2_3_info *data = (calc_gz_lev_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statet = data->new_statet;
  __attribute__ ((aligned (32))) double new_statet[bz+2*hz][bx+2*hx];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[bz+2*hz][bx+2*hx];
  
  double *_staticvgzs = data->staticvgzs;
  __attribute__ ((aligned (32))) double staticvgzs[bz+2*hz][bx+2*hx];
  
  double *_new_stategz_lev = data->new_stategz_lev;
  __attribute__ ((aligned (32))) double new_stategz_lev[bz+2*hz][bx+2*hx];
  
  double dgz;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_statet+(k*fnumy*fnumx+jb*fnumx+ib), &new_statet[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(jb*fnumx+ib), &staticvgzs[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_statet+(k*fnumy*fnumx+jb*fnumx+ib), &new_statet[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_staticvgzs+(k*fnumy*fnumx+jb*fnumx+ib), &staticvgzs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            dgz = 0.0;
            for (l=k;l<((32 - 1) + 1)+ghz;l+=1){
              dgz = (dgz + ((287.04 * new_statet[swindex[l]][i]) * log((new_stateph_lev[swindex[(l + 1)]][i] / new_stateph_lev[swindex[l]][i]))));
            }
            new_stategz_lev[k][i] = (staticvgzs[swindex[0]][i] + dgz);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stategz_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void pgf_lin97_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  pgf_lin97_2_2_info *data = (pgf_lin97_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateqm = data->new_stateqm;
  __attribute__ ((aligned (32))) double new_stateqm[6][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[6][258];
  
  double *_new_stategz_lev = data->new_stategz_lev;
  __attribute__ ((aligned (32))) double new_stategz_lev[6][258];
  
  double *_tend2pgf_lon = data->tend2pgf_lon;
  __attribute__ ((aligned (32))) double tend2pgf_lon[6][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double tl;
  double dph1;
  double dph2;
  double dgz1;
  double dgz2;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateqm+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateqm[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_exn_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_exn_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stategz_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateqm+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateqm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_exn_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_exn_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stategz_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stategz_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            tl = (1 + (0.5 * (new_stateqm[swindex[k]][i] + new_stateqm[swindex[k]][(i + 1)])));
            dph1 = (new_stateph_exn_lev[swindex[(k + 1)]][(i + 1)] - new_stateph_exn_lev[swindex[k]][i]);
            dph2 = (new_stateph_exn_lev[swindex[(k + 1)]][i] - new_stateph_exn_lev[swindex[k]][(i + 1)]);
            dgz1 = (new_stategz_lev[swindex[(k + 1)]][i] - new_stategz_lev[swindex[k]][(i + 1)]);
            dgz2 = (new_stategz_lev[swindex[k]][i] - new_stategz_lev[swindex[(k + 1)]][(i + 1)]);
            tend2pgf_lon[k][i] = (((-((dph1 * dgz1) + (dph2 * dgz2)) / de_lon[jb+oy]) / (dph1 + dph2)) / tl);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_tend2pgf_lon+(k*fnumy*fnumx+jb*fnumx+ib+hx), &tend2pgf_lon[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_backward_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_backward_2_4_info *data = (calc_tend_backward_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1du = data->tend1du;
  __attribute__ ((aligned (32))) double tend1du[10][258];
  
  double *_tend2pgf_lon = data->tend2pgf_lon;
  __attribute__ ((aligned (32))) double tend2pgf_lon[10][258];
  
  double *_tend2du = data->tend2du;
  __attribute__ ((aligned (32))) double tend2du[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &tend2pgf_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1du+(kb*fnumy*fnumx+j*fnumx+ib), &tend1du[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &tend2pgf_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend2du[j][i] = (tend1du[swindex[j]][i] - tend2pgf_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tend2du[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_tend_backward_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_tend_backward_2_5_info *data = (calc_tend_backward_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_tend1dv = data->tend1dv;
  __attribute__ ((aligned (32))) double tend1dv[10][258];
  
  double *_tend2pgf_lat = data->tend2pgf_lat;
  __attribute__ ((aligned (32))) double tend2pgf_lat[10][258];
  
  double *_tend2dv = data->tend2dv;
  __attribute__ ((aligned (32))) double tend2dv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &tend2pgf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_tend1dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend1dv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2pgf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &tend2pgf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tend2dv[j][i] = (tend1dv[swindex[j]][i] - tend2pgf_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tend2dv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_18_info *data = (calc_ph_2_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statephs = data->new_statephs;
  __attribute__ ((aligned (32))) double new_statephs[10][258];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statephs+(j*fnumx+ib), &new_statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],new_statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_19_info *data = (calc_ph_2_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[10][258];
  
  double *_new_stateph_exn_lev = data->new_stateph_exn_lev;
  __attribute__ ((aligned (32))) double new_stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph_exn_lev[j][i] = pow(new_stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_20_info *data = (calc_ph_2_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateph[k][i] = (0.5 * (new_stateph_lev[k][i] + new_stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_44(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_44_info *data = (calc_m_2_44_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_45(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_45_info *data = (calc_m_2_45_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_46(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_46_info *data = (calc_m_2_46_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_47(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_47_info *data = (calc_m_2_47_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_2_11_info *data = (averageCellToLonEdge_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_2_11_info *data = (averageCellToLatEdge_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_2_11_info *data = (interpCellToVtx_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_20(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_20_info *data = (update_state_2_20_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statept = data->old_statept;
  __attribute__ ((aligned (32))) double old_statept[12][260];
  
  double *_old_statem = data->old_statem;
  __attribute__ ((aligned (32))) double old_statem[12][260];
  
  double *_tend2dpt = data->tend2dpt;
  __attribute__ ((aligned (32))) double tend2dpt[12][260];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[12][260];
  
  double *_new_statept = data->new_statept;
  __attribute__ ((aligned (32))) double new_statept[12][260];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dpt[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statept+(kb*fnumy*fnumx+j*fnumx+ib), &old_statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_old_statem+(kb*fnumy*fnumx+j*fnumx+ib), &old_statem[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dpt+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dpt[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statept[j][i] = (((old_statept[swindex[j]][i] * old_statem[swindex[j]][i]) + (dt * tend2dpt[swindex[j]][i])) / new_statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_21_info *data = (update_state_2_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stategz = data->old_stategz;
  __attribute__ ((aligned (32))) double old_stategz[8][256];
  
  double *_tend2dgz = data->tend2dgz;
  __attribute__ ((aligned (32))) double tend2dgz[8][256];
  
  double *_new_stategz = data->new_stategz;
  __attribute__ ((aligned (32))) double new_stategz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dgz[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stategz+(kb*fnumy*fnumx+j*fnumx+ib), &old_stategz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dgz+(kb*fnumy*fnumx+j*fnumx+ib), &tend2dgz[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stategz[j][i] = (old_stategz[swindex[j]][i] + (dt * tend2dgz[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stategz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stategz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_48(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_48_info *data = (calc_m_2_48_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][258];
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem[k][i] = (new_stateph_lev[swindex[(k + 1)]][i] - new_stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_49(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_49_info *data = (calc_m_2_49_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_50(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_50_info *data = (calc_m_2_50_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[8][256];
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[8][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[j][i] = (new_stateph[swindex[j]][i] - new_stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_51(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_51_info *data = (calc_m_2_51_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_stateph_lev = data->new_stateph_lev;
  __attribute__ ((aligned (32))) double new_stateph_lev[6][256];
  
  double *_new_stateph = data->new_stateph;
  __attribute__ ((aligned (32))) double new_stateph[6][256];
  
  double *_new_statem_lev = data->new_statem_lev;
  __attribute__ ((aligned (32))) double new_statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_new_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_new_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &new_stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lev[k][i] = (new_stateph_lev[swindex[k]][i] - new_stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_new_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &new_statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_2_12_info *data = (averageCellToLonEdge_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lon = data->new_statem_lon;
  __attribute__ ((aligned (32))) double new_statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lon[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_2_12_info *data = (averageCellToLatEdge_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_lat = data->new_statem_lat;
  __attribute__ ((aligned (32))) double new_statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_lat[j][i] = ((new_statem[swindex[j]][i] + new_statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_2_12(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_2_12_info *data = (interpCellToVtx_2_12_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_new_statem = data->new_statem;
  __attribute__ ((aligned (32))) double new_statem[10][258];
  
  double *_new_statem_vtx = data->new_statem_vtx;
  __attribute__ ((aligned (32))) double new_statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_new_statem+(kb*fnumy*fnumx+j*fnumx+ib), &new_statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statem_vtx[j][i] = ((((new_statem[swindex[j]][i] + new_statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((new_statem[swindex[(j + 1)]][i] + new_statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_22_info *data = (update_state_2_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_stateu_lon = data->old_stateu_lon;
  __attribute__ ((aligned (32))) double old_stateu_lon[10][258];
  
  double *_tend2du = data->tend2du;
  __attribute__ ((aligned (32))) double tend2du[10][258];
  
  double *_new_stateu_lon = data->new_stateu_lon;
  __attribute__ ((aligned (32))) double new_stateu_lon[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib), &tend2du[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &old_stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2du+(kb*fnumy*fnumx+j*fnumx+ib), &tend2du[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_stateu_lon[j][i] = (old_stateu_lon[swindex[j]][i] + (dt * tend2du[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &new_stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void update_state_2_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  update_state_2_23_info *data = (update_state_2_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_old_statev_lat = data->old_statev_lat;
  __attribute__ ((aligned (32))) double old_statev_lat[10][258];
  
  double *_tend2dv = data->tend2dv;
  __attribute__ ((aligned (32))) double tend2dv[10][258];
  
  double *_new_statev_lat = data->new_statev_lat;
  __attribute__ ((aligned (32))) double new_statev_lat[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend2dv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_old_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &old_statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tend2dv+(kb*hnumy*hnumx+j*hnumx+ib), &tend2dv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            new_statev_lat[j][i] = (old_statev_lat[swindex[j]][i] + (dt * tend2dv[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_new_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &new_statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void smag_damp_run_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_0_info *data = (smag_damp_run_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statesmag_t[j][i] = (((stateu_lon[swindex[j]][i] - stateu_lon[swindex[j]][(i - 1)]) / de_lon[j+jb+oy]) - ((((statev_lat[swindex[j]][i] * half_cos_lat[j+jb+oy]) - (statev_lat[swindex[(j - 1)]][i] * half_cos_lat[(j+jb+oy - 1)])) / le_lon[j+jb+oy]) / full_cos_lat[j+jb+oy]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statesmag_t[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_1_info *data = (smag_damp_run_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statesmag_s[j][i] = (((statev_lat[swindex[j]][(i + 1)] - statev_lat[swindex[j]][i]) / le_lat[j+jb+oy]) + ((((stateu_lon[swindex[(j + 1)]][i] * full_cos_lat[(j+jb+oy + 1)]) - (stateu_lon[swindex[j]][i] * full_cos_lat[j+jb+oy])) / de_lat[j+jb+oy]) / half_cos_lat[j+jb+oy]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statesmag_s[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_2_info *data = (smag_damp_run_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_statekmh_lon = data->statekmh_lon;
  __attribute__ ((aligned (32))) double statekmh_lon[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statekmh_lon[j][i] = ((0.1 / ((1.0 / pow(de_lon[j+jb+oy],2)) + (1 / pow(le_lon[j+jb+oy],2)))) * sqrt(((0.5 * (pow(statesmag_t[swindex[j]][i],2) + pow(statesmag_t[swindex[j]][(i + 1)],2))) + (0.5 * (pow(statesmag_s[swindex[j]][i],2) + pow(statesmag_s[swindex[(j - 1)]][i],2))))));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statekmh_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_3_info *data = (smag_damp_run_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statesmag_t = data->statesmag_t;
  __attribute__ ((aligned (32))) double statesmag_t[10][258];
  
  double *_statesmag_s = data->statesmag_s;
  __attribute__ ((aligned (32))) double statesmag_s[10][258];
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statesmag_t+(kb*fnumy*fnumx+j*fnumx+ib), &statesmag_t[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statesmag_s+(kb*hnumy*hnumx+j*hnumx+ib), &statesmag_s[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statekmh_lat[j][i] = ((0.1 / ((1.0 / pow(le_lat[j+jb+oy],2)) + (1 / pow(de_lat[j+jb+oy],2)))) * sqrt(((0.5 * (pow(statesmag_t[swindex[j]][i],2) + pow(statesmag_t[swindex[(j + 1)]][i],2))) + (0.5 * (pow(statesmag_s[swindex[j]][i],2) + pow(statesmag_s[swindex[j]][(i - 1)],2))))));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statekmh_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_4_info *data = (smag_damp_run_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lon = data->statekmh_lon;
  __attribute__ ((aligned (32))) double statekmh_lon[10][258];
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_tendsmag_dudt = data->tendsmag_dudt;
  __attribute__ ((aligned (32))) double tendsmag_dudt[10][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statekmh_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lon+(kb*fnumy*fnumx+j*fnumx+ib), &statekmh_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dudt[j][i] = (statekmh_lon[swindex[j]][i] * ((((stateu_lon[swindex[j]][(i - 1)] - (2 * stateu_lon[swindex[j]][i])) + stateu_lon[swindex[j]][(i + 1)]) / pow(de_lon[j+jb+oy],2)) + ((((((stateu_lon[swindex[(j + 1)]][i] - stateu_lon[swindex[j]][i]) / de_lat[j+jb+oy]) * half_cos_lat[j+jb+oy]) - (((stateu_lon[swindex[j]][i] - stateu_lon[swindex[(j - 1)]][i]) / de_lat[(j+jb+oy - 1)]) * half_cos_lat[(j+jb+oy - 1)])) / le_lon[j+jb+oy]) / full_cos_lat[j+jb+oy])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib+hx), &tendsmag_dudt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_5_info *data = (smag_damp_run_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_tendsmag_dudt = data->tendsmag_dudt;
  __attribute__ ((aligned (32))) double tendsmag_dudt[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib), &tendsmag_dudt[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dudt+(kb*fnumy*fnumx+j*fnumx+ib), &tendsmag_dudt[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu_lon[j][i] = (stateu_lon[j][i] + (dt * tendsmag_dudt[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_6_info *data = (smag_damp_run_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_full_cos_lat = data->full_cos_lat;
  __attribute__ ((aligned (32))) double full_cos_lat[fny+2*hy];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  double *_half_cos_lat = data->half_cos_lat;
  __attribute__ ((aligned (32))) double half_cos_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_full_cos_lat+(ghy-hy), &full_cos_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_half_cos_lat+(ghy-hy), &half_cos_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dvdt[j][i] = (statekmh_lat[swindex[j]][i] * ((((statev_lat[swindex[j]][(i - 1)] - (2 * statev_lat[swindex[j]][i])) + statev_lat[swindex[j]][(i + 1)]) / pow(le_lat[j+jb+oy],2)) + ((((((statev_lat[swindex[(j + 1)]][i] - statev_lat[swindex[j]][i]) / le_lon[(j+jb+oy + 1)]) * full_cos_lat[(j+jb+oy + 1)]) - (((statev_lat[swindex[j]][i] - statev_lat[swindex[(j - 1)]][i]) / le_lon[j+jb+oy]) * full_cos_lat[j+jb+oy])) / de_lat[j+jb+oy]) / half_cos_lat[j+jb+oy])));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tendsmag_dvdt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_7_info *data = (smag_damp_run_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statekmh_lat = data->statekmh_lat;
  __attribute__ ((aligned (32))) double statekmh_lat[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statekmh_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statekmh_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            tendsmag_dvdt[j][i] = (statekmh_lat[swindex[j]][i] * (((statev_lat[swindex[j]][(i - 1)] - (2 * statev_lat[swindex[j]][i])) + statev_lat[swindex[j]][(i + 1)]) / pow(le_lat[j+jb+oy],2)));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib+hx), &tendsmag_dvdt[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void smag_damp_run_2_8(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  smag_damp_run_2_8_info *data = (smag_damp_run_2_8_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_tendsmag_dvdt = data->tendsmag_dvdt;
  __attribute__ ((aligned (32))) double tendsmag_dvdt[10][258];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib), &tendsmag_dvdt[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_tendsmag_dvdt+(kb*hnumy*hnumx+j*hnumx+ib), &tendsmag_dvdt[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statev_lat[j][i] = (statev_lat[j][i] + (dt * tendsmag_dvdt[swindex[j]][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statev_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void trickypt_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  trickypt_2_0_info *data = (trickypt_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statept[j][i] = (statept[j][i] * statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_21(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_21_info *data = (calc_ph_2_21_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statephs = data->statephs;
  __attribute__ ((aligned (32))) double statephs[10][258];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_hyai = data->hyai;
  __attribute__ ((aligned (32))) double hyai[hnz+2*hz];
  
  double *_hybi = data->hybi;
  __attribute__ ((aligned (32))) double hybi[hnz+2*hz];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hnz + 2*hz;
  DMA_READ(_hyai+(ghz-hz), &hyai[0], dmasize* sizeof(double));
  dmasize = hnz + 2*hz;
  DMA_READ(_hybi+(ghz-hz), &hybi[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statephs+(j*fnumx+ib), &statephs[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_lev[j][i] = slave_hybrid_coord_calc_ph_lev(hyai[kb+oz],hybi[kb+oz],statephs[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_22(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_22_info *data = (calc_ph_2_22_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[10][258];
  
  double *_stateph_exn_lev = data->stateph_exn_lev;
  __attribute__ ((aligned (32))) double stateph_exn_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateph_exn_lev[j][i] = pow(stateph_lev[swindex[j]][i],0.2858964143426295);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateph_exn_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateph_exn_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_ph_2_23(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_ph_2_23_info *data = (calc_ph_2_23_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            stateph[k][i] = (0.5 * (stateph_lev[k][i] + stateph_lev[(k + 1)][i]));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_stateph+(k*fnumy*fnumx+jb*fnumx+ib+hx), &stateph[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_52(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_52_info *data = (calc_m_2_52_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][258];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[6][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem[k][i] = (stateph_lev[swindex[(k + 1)]][i] - stateph_lev[swindex[k]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_53(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_53_info *data = (calc_m_2_53_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_54(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_54_info *data = (calc_m_2_54_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[8][256];
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[8][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateph+(kb*fnumy*fnumx+j*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph_lev+(kb*fnumy*fnumx+j*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[j][i] = (stateph[swindex[j]][i] - stateph_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void calc_m_2_55(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  calc_m_2_55_info *data = (calc_m_2_55_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateph_lev = data->stateph_lev;
  __attribute__ ((aligned (32))) double stateph_lev[6][256];
  
  double *_stateph = data->stateph;
  __attribute__ ((aligned (32))) double stateph[6][256];
  
  double *_statem_lev = data->statem_lev;
  __attribute__ ((aligned (32))) double statem_lev[6][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_stateph_lev+(k*fnumy*fnumx+jb*fnumx+ib), &stateph_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_stateph+(k*fnumy*fnumx+jb*fnumx+ib), &stateph[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lev[k][i] = (stateph_lev[swindex[k]][i] - stateph[swindex[(k - 1)]][i]);
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_statem_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &statem_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLonEdge_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLonEdge_2_13_info *data = (averageCellToLonEdge_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lon = data->statem_lon;
  __attribute__ ((aligned (32))) double statem_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lon[j][i] = ((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statem_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void averageCellToLatEdge_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  averageCellToLatEdge_2_13_info *data = (averageCellToLatEdge_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_lat = data->statem_lat;
  __attribute__ ((aligned (32))) double statem_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_lat[j][i] = ((statem[swindex[j]][i] + statem[swindex[(j + 1)]][i]) * 0.5);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void interpCellToVtx_2_13(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  interpCellToVtx_2_13_info *data = (interpCellToVtx_2_13_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[10][258];
  
  double *_statem_vtx = data->statem_vtx;
  __attribute__ ((aligned (32))) double statem_vtx[10][258];
  
  double *_area_subcell_1 = data->area_subcell_1;
  __attribute__ ((aligned (32))) double area_subcell_1[fny+2*hy];
  
  double *_area_subcell_0 = data->area_subcell_0;
  __attribute__ ((aligned (32))) double area_subcell_0[fny+2*hy];
  
  double *_area_vtx = data->area_vtx;
  __attribute__ ((aligned (32))) double area_vtx[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_1+(ghy-hy), &area_subcell_1[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_subcell_0+(ghy-hy), &area_subcell_0[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_area_vtx+(ghy-hy), &area_vtx[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statem_vtx[j][i] = ((((statem[swindex[j]][i] + statem[swindex[j]][(i + 1)]) * area_subcell_1[j+jb+oy]) + ((statem[swindex[(j + 1)]][i] + statem[swindex[(j + 1)]][(i + 1)]) * area_subcell_0[(j+jb+oy + 1)])) / area_vtx[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statem_vtx+(kb*hnumy*hnumx+j*hnumx+ib+hx), &statem_vtx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void pole_damp_run_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  pole_damp_run_2_0_info *data = (pole_damp_run_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_statept = data->statept;
  __attribute__ ((aligned (32))) double statept[12][260];
  
  double *_statem = data->statem;
  __attribute__ ((aligned (32))) double statem[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_statept+(kb*fnumy*fnumx+j*fnumx+ib), &statept[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statem+(kb*fnumy*fnumx+j*fnumx+ib), &statem[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            statept[j][i] = (statept[j][i] / statem[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_statept+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statept[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}

void c2a_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  c2a_2_1_info *data = (c2a_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_stateu_lon = data->stateu_lon;
  __attribute__ ((aligned (32))) double stateu_lon[10][258];
  
  double *_statev_lat = data->statev_lat;
  __attribute__ ((aligned (32))) double statev_lat[10][258];
  
  double *_stateu = data->stateu;
  __attribute__ ((aligned (32))) double stateu[10][258];
  
  double *_statev = data->statev;
  __attribute__ ((aligned (32))) double statev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_stateu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &stateu_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_statev_lat+(kb*hnumy*hnumx+j*hnumx+ib), &statev_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            stateu[j][i] = (0.5 * (stateu_lon[j][i] + stateu_lon[j][(i - 1)]));
            statev[j][i] = (0.5 * (statev_lat[j][i] + statev_lat[(j - 1)][i]));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_stateu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &stateu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_statev+(kb*fnumy*fnumx+j*fnumx+ib+hx), &statev[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}


void accum_uv_cell_2_60(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_60_info *data = (accum_uv_cell_2_60_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advu0 = data->advu0;
  __attribute__ ((aligned (32))) double advu0[8][258];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advu0+(kb*fnumy*fnumx+j*fnumx+ib), &advu0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advu0+(kb*fnumy*fnumx+j*fnumx+ib), &advu0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = advu0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_61(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_61_info *data = (accum_uv_cell_2_61_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advv0 = data->advv0;
  __attribute__ ((aligned (32))) double advv0[10][256];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advv0+(kb*hnumy*hnumx+j*hnumx+ib), &advv0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advv0+(kb*hnumy*hnumx+j*hnumx+ib), &advv0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = advv0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_62(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_62_info *data = (accum_uv_cell_2_62_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = state_oldu_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_63(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_63_info *data = (accum_uv_cell_2_63_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = state_oldv_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_64(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_64_info *data = (accum_uv_cell_2_64_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = ((advuu[j][i] + state_oldu_lon[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_65(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_65_info *data = (accum_uv_cell_2_65_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = ((advvv[j][i] + state_oldv_lat[swindex[j]][i]) / ((nstep) + 1));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_66(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_66_info *data = (accum_uv_cell_2_66_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  double *_advu0 = data->advu0;
  __attribute__ ((aligned (32))) double advu0[8][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advu0[j][i] = advuu[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advu0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advu0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_67(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_67_info *data = (accum_uv_cell_2_67_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advv0 = data->advv0;
  __attribute__ ((aligned (32))) double advv0[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advv0[j][i] = advvv[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advv0+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advv0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_68(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_68_info *data = (accum_uv_cell_2_68_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_state_oldu_lon = data->state_oldu_lon;
  __attribute__ ((aligned (32))) double state_oldu_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldu_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldu_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advuu[j][i] = (advuu[j][i] + state_oldu_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advuu+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advuu[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_69(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_69_info *data = (accum_uv_cell_2_69_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_state_oldv_lat = data->state_oldv_lat;
  __attribute__ ((aligned (32))) double state_oldv_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldv_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldv_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advvv[j][i] = (advvv[j][i] + state_oldv_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advvv+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advvv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_70(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_70_info *data = (accum_uv_cell_2_70_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[8][258];
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[8][258];
  
  double *_de_lon = data->de_lon;
  __attribute__ ((aligned (32))) double de_lon[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_de_lon+(ghy-hy), &de_lon[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcflx[j][i] = ((advuu[swindex[j]][i] * dt) / de_lon[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advcflx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_71(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_71_info *data = (accum_uv_cell_2_71_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_de_lat = data->de_lat;
  __attribute__ ((aligned (32))) double de_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_de_lat+(ghy-hy), &de_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcfly[j][i] = ((advvv[swindex[j]][i] * dt) / de_lat[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advcfly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_72(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_72_info *data = (accum_uv_cell_2_72_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[10][258];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][258];
  
  double *_advdivx = data->advdivx;
  __attribute__ ((aligned (32))) double advdivx[10][258];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[10][258];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advdivx[j][i] = (((advuu[swindex[j]][i] - advuu[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]);
            advdivy[j][i] = (((advvv[swindex[j]][i] * le_lat[j+jb+oy]) - (advvv[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_73(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_73_info *data = (accum_uv_cell_2_73_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_oldtmpsum[j][i] = -advvv[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_oldtmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_uv_cell_2_74(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_uv_cell_2_74_info *data = (accum_uv_cell_2_74_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[8][256];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[8][256];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advdivy[j][i] = (((state_oldtmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdivy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_24(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_24_info *data = (accum_mf_cell_2_24_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = state_oldmfx_lon[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_25(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_25_info *data = (accum_mf_cell_2_25_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = state_oldmfy_lat[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_26(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_26_info *data = (accum_mf_cell_2_26_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = ((advmfx[j][i] + state_oldmfx_lon[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_27(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_27_info *data = (accum_mf_cell_2_27_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = ((advmfy[j][i] + state_oldmfy_lat[swindex[j]][i]) / (nstep));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_28(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_28_info *data = (accum_mf_cell_2_28_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[10][258];
  
  double *_state_oldmfx_lon = data->state_oldmfx_lon;
  __attribute__ ((aligned (32))) double state_oldmfx_lon[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfx_lon+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldmfx_lon[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfx[j][i] = (advmfx[j][i] + state_oldmfx_lon[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmfx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_mf_cell_2_29(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_mf_cell_2_29_info *data = (accum_mf_cell_2_29_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][258];
  
  double *_state_oldmfy_lat = data->state_oldmfy_lat;
  __attribute__ ((aligned (32))) double state_oldmfy_lat[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldmfy_lat+(kb*hnumy*hnumx+j*hnumx+ib), &state_oldmfy_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advmfy[j][i] = (advmfy[j][i] + state_oldmfy_lat[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advmfy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_15(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_15_info *data = (accum_we_lev_2_15_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe0 = data->advwe0;
  __attribute__ ((aligned (32))) double advwe0[8][256];
  
  double *_advm0 = data->advm0;
  __attribute__ ((aligned (32))) double advm0[8][256];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[8][256];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[8][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advwe0[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advm0+(kb*fnumy*fnumx+j*fnumx+ib), &advm0[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib), &advwe0[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advm0+(kb*fnumy*fnumx+j*fnumx+ib), &advm0[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = advwe0[j][i];
            advmm[j][i] = advm0[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_16(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_16_info *data = (accum_we_lev_2_16_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = state_oldwe_lev[swindex[j]][i];
            advmm[j][i] = state_oldm_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_17(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_17_info *data = (accum_we_lev_2_17_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  double *_advwe0 = data->advwe0;
  __attribute__ ((aligned (32))) double advwe0[10][258];
  
  double *_advm0 = data->advm0;
  __attribute__ ((aligned (32))) double advm0[10][258];
  
  
  int nstep = data->nstep;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = ((advwe[j][i] + state_oldwe_lev[swindex[j]][i]) / ((nstep) + 1));
            advmm[j][i] = ((advmm[j][i] + state_oldm_lev[swindex[j]][i]) / ((nstep) + 1));
            advwe0[j][i] = state_oldwe_lev[swindex[j]][i];
            advm0[j][i] = state_oldm_lev[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advwe0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advm0+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advm0[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_18(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_18_info *data = (accum_we_lev_2_18_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[10][258];
  
  double *_state_oldwe_lev = data->state_oldwe_lev;
  __attribute__ ((aligned (32))) double state_oldwe_lev[10][258];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[10][258];
  
  double *_state_oldm_lev = data->state_oldm_lev;
  __attribute__ ((aligned (32))) double state_oldm_lev[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldwe_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldwe_lev[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm_lev+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advwe[j][i] = (advwe[j][i] + state_oldwe_lev[swindex[j]][i]);
            advmm[j][i] = (advmm[j][i] + state_oldm_lev[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advwe+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advwe[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advmm+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advmm[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void accum_we_lev_2_19(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  accum_we_lev_2_19_info *data = (accum_we_lev_2_19_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[8][256];
  
  double *_advmm = data->advmm;
  __attribute__ ((aligned (32))) double advmm[8][256];
  
  double *_advcflz = data->advcflz;
  __attribute__ ((aligned (32))) double advcflz[8][256];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advwe+(kb*fnumy*fnumx+j*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmm+(kb*fnumy*fnumx+j*fnumx+ib), &advmm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advcflz[j][i] = ((advwe[swindex[j]][i] / advmm[swindex[j]][i]) * dt);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advcflz+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advcflz[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_2_9_info *data = (hflx_ppm_inner_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[12][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[12][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[12][260];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[12][260];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[12][260];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(state_oldqv[swindex[j]][(i - 2)],state_oldqv[swindex[j]][(i - 1)],state_oldqv[swindex[j]][i],state_oldqv[swindex[j]][(i + 1)],state_oldqv[swindex[j]][(i + 2)]);
            advqlx[j][i] = buf.x;
            advdqx[j][i] = buf.y;
            advq6x[j][i] = buf.z;
            buf = slave_ppm(state_oldqv[swindex[(j - 2)]][i],state_oldqv[swindex[(j - 1)]][i],state_oldqv[swindex[j]][i],state_oldqv[swindex[(j + 1)]][i],state_oldqv[swindex[(j + 2)]][i]);
            advqly[j][i] = buf.x;
            advdqy[j][i] = buf.y;
            advq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_2_10_info *data = (hflx_ppm_inner_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[by+2*hy][bx+2*hx];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[by+2*hy][bx+2*hx];
  
  double *_advuu = data->advuu;
  __attribute__ ((aligned (32))) double advuu[by+2*hy][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[by+2*hy][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[by+2*hy][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[by+2*hy][bx+2*hx];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advuu+(kb*fnumy*fnumx+j*fnumx+ib), &advuu[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflx[swindex[j]][i]);
            cf = (advcflx[swindex[j]][i] - ci);
            if ((advcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + state_oldqv[swindex[j]][l]);
              }
              advqmf_lon[j][i] = ((advuu[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advdqx[swindex[j]][(i - ci)]) * ds2)) + (advq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
            }
            else
            {
              if ((advcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + state_oldqv[swindex[j]][l]);
                }
                advqmf_lon[j][i] = ((-advuu[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
              }
              else
              {
                advqmf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqmf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_inner_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_inner_2_11_info *data = (hflx_ppm_inner_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_advvv = data->advvv;
  __attribute__ ((aligned (32))) double advvv[10][256];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[10][256];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[10][256];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[10][256];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advvv+(kb*hnumy*hnumx+j*hnumx+ib), &advvv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              advqmf_lat[j][i] = ((advvv[swindex[j]][i] * (((advqly[swindex[j]][i] * ds1) + ((0.5 * advdqy[swindex[j]][i]) * ds2)) + (advq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
            }
            else
            {
              if ((advcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                advqmf_lat[j][i] = ((-advvv[swindex[j]][i] * (((advqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advdqy[swindex[(j + 1)]][i]) * ds2)) + (advq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
              }
              else
              {
                advqmf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advqmf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_2_9_info *data = (ffsl_calc_tracer_hflx_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[12][260];
  
  double *_advdivx = data->advdivx;
  __attribute__ ((aligned (32))) double advdivx[12][260];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[12][260];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advdivx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivx+(kb*fnumy*fnumx+j*fnumx+ib), &advdivx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advqx[j][i] = (state_oldqv[swindex[j]][i] - ((0.5 * ((((advqmf_lon[swindex[j]][i] - advqmf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy]) / area_cell[j+jb+oy]) - (advdivx[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
            advqy[j][i] = (state_oldqv[swindex[j]][i] - ((0.5 * ((((advqmf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (advqmf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) - (advdivy[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_2_10_info *data = (ffsl_calc_tracer_hflx_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_oldtmpsum[j][i] = advqmf_lat[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_oldtmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void ffsl_calc_tracer_hflx_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  ffsl_calc_tracer_hflx_2_11_info *data = (ffsl_calc_tracer_hflx_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_state_oldtmpsum = data->state_oldtmpsum;
  __attribute__ ((aligned (32))) double state_oldtmpsum[12][260];
  
  double *_advdivy = data->advdivy;
  __attribute__ ((aligned (32))) double advdivy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  double dt = data->dt;
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldtmpsum[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdivy+(kb*fnumy*fnumx+j*fnumx+ib), &advdivy[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advqx[j][i] = state_oldqv[swindex[j]][i];
            advqy[j][i] = (state_oldqv[swindex[j]][i] + ((0.5 * ((((state_oldtmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]) - (advdivy[swindex[j]][i] * state_oldqv[swindex[j]][i]))) * dt));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_2_9(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_2_9_info *data = (hflx_ppm_outer_2_9_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[12][260];
  
  double *_advqx = data->advqx;
  __attribute__ ((aligned (32))) double advqx[12][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[12][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[12][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[12][260];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[12][260];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[12][260];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[12][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqx+(kb*fnumy*fnumx+j*fnumx+ib), &advqx[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqx+(kb*fnumy*fnumx+j*fnumx+ib), &advqx[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(advqy[swindex[j]][(i - 2)],advqy[swindex[j]][(i - 1)],advqy[swindex[j]][i],advqy[swindex[j]][(i + 1)],advqy[swindex[j]][(i + 2)]);
            advqlx[j][i] = buf.x;
            advdqx[j][i] = buf.y;
            advq6x[j][i] = buf.z;
            buf = slave_ppm(advqx[swindex[(j - 2)]][i],advqx[swindex[(j - 1)]][i],advqx[swindex[j]][i],advqx[swindex[(j + 1)]][i],advqx[swindex[(j + 2)]][i]);
            advqly[j][i] = buf.x;
            advdqy[j][i] = buf.y;
            advq6y[j][i] = buf.z;
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqlx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqx[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6x[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advqly+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqly[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advdqy[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advq6y[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_2_10(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_2_10_info *data = (hflx_ppm_outer_2_10_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflx = data->advcflx;
  __attribute__ ((aligned (32))) double advcflx[by+2*hy][bx+2*hx];
  
  double *_advqy = data->advqy;
  __attribute__ ((aligned (32))) double advqy[by+2*hy][bx+2*hx];
  
  double *_advmfx = data->advmfx;
  __attribute__ ((aligned (32))) double advmfx[by+2*hy][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[by+2*hy][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[by+2*hy][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[by+2*hy][bx+2*hx];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[by+2*hy][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcflx+(kb*fnumy*fnumx+j*fnumx+ib), &advcflx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqy+(kb*fnumy*fnumx+j*fnumx+ib), &advqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfx+(kb*fnumy*fnumx+j*fnumx+ib), &advmfx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(kb*fnumy*fnumx+j*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(kb*fnumy*fnumx+j*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(kb*fnumy*fnumx+j*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflx[swindex[j]][i]);
            cf = (advcflx[swindex[j]][i] - ci);
            if ((advcflx[swindex[j]][i] > 0.0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=((i + 1) - ci);l<(i + 1);l+=1){
                cursum = (cursum + advqy[swindex[j]][l]);
              }
              advqmf_lon[j][i] = ((advmfx[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][(i - ci)] * ds1)) + ((0.5 * advdqx[swindex[j]][(i - ci)]) * ds2)) + (advq6x[swindex[j]][(i - ci)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
            }
            else
            {
              if ((advcflx[swindex[j]][i] < 0.0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                cursum = 0.0;
                for (l=(i + 1);l<((i - ci) + 1);l+=1){
                  cursum = (cursum + advqy[swindex[j]][l]);
                }
                advqmf_lon[j][i] = ((-advmfx[swindex[j]][i] * (((cursum + (advqlx[swindex[j]][((i - ci) + 1)] * ds1)) + ((0.5 * advdqx[swindex[j]][((i - ci) + 1)]) * ds2)) + (advq6x[swindex[j]][((i - ci) + 1)] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflx[swindex[j]][i]);
              }
              else
              {
                advqmf_lon[j][i] = 0.0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advqmf_lon[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void hflx_ppm_outer_2_11(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  hflx_ppm_outer_2_11_info *data = (hflx_ppm_outer_2_11_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcfly = data->advcfly;
  __attribute__ ((aligned (32))) double advcfly[10][256];
  
  double *_advmfy = data->advmfy;
  __attribute__ ((aligned (32))) double advmfy[10][256];
  
  double *_advqly = data->advqly;
  __attribute__ ((aligned (32))) double advqly[10][256];
  
  double *_advdqy = data->advdqy;
  __attribute__ ((aligned (32))) double advdqy[10][256];
  
  double *_advq6y = data->advq6y;
  __attribute__ ((aligned (32))) double advq6y[10][256];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advcfly+(kb*hnumy*hnumx+j*hnumx+ib), &advcfly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advmfy+(kb*hnumy*hnumx+j*hnumx+ib), &advmfy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqly+(kb*fnumy*fnumx+j*fnumx+ib), &advqly[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqy+(kb*fnumy*fnumx+j*fnumx+ib), &advdqy[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6y+(kb*fnumy*fnumx+j*fnumx+ib), &advq6y[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            if ((advcfly[swindex[j]][i] > 0))
            {
              s1 = (1 - advcfly[swindex[j]][i]);
              s2 = 1;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              advqmf_lat[j][i] = ((advmfy[swindex[j]][i] * (((advqly[swindex[j]][i] * ds1) + ((0.5 * advdqy[swindex[j]][i]) * ds2)) + (advq6y[swindex[j]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
            }
            else
            {
              if ((advcfly[swindex[j]][i] < 0))
              {
                s1 = 0;
                s2 = -advcfly[swindex[j]][i];
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                advqmf_lat[j][i] = ((-advmfy[swindex[j]][i] * (((advqly[swindex[(j + 1)]][i] * ds1) + ((0.5 * advdqy[swindex[(j + 1)]][i]) * ds2)) + (advq6y[swindex[(j + 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcfly[swindex[j]][i]);
              }
              else
              {
                advqmf_lat[j][i] = 0;
              }
            }
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib+hx), &advqmf_lat[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_2_0(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_2_0_info *data = (adv_run_2_0_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[12][260];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_advqmf_lon = data->advqmf_lon;
  __attribute__ ((aligned (32))) double advqmf_lon[12][260];
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[12][260];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_le_lon = data->le_lon;
  __attribute__ ((aligned (32))) double le_lon[fny+2*hy];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = fny + 2*hy;
  DMA_READ(_le_lon+(ghy-hy), &le_lon[0], dmasize* sizeof(double));
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lon+(kb*fnumy*fnumx+j*fnumx+ib), &advqmf_lon[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (((advold_m[swindex[j]][i] * state_oldqv[swindex[j]][i]) - ((advqmf_lon[swindex[j]][i] - advqmf_lon[swindex[j]][(i - 1)]) * le_lon[j+jb+oy])) + ((((advqmf_lat[swindex[j]][i] * le_lat[j+jb+oy]) - (advqmf_lat[swindex[(j - 1)]][i] * le_lat[(j+jb+oy - 1)])) / area_cell[j+jb+oy]) * 30));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_2_1(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_2_1_info *data = (adv_run_2_1_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advqmf_lat = data->advqmf_lat;
  __attribute__ ((aligned (32))) double advqmf_lat[10][256];
  
  double *_state_newtmpsum = data->state_newtmpsum;
  __attribute__ ((aligned (32))) double state_newtmpsum[10][256];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advqmf_lat+(kb*hnumy*hnumx+j*hnumx+ib), &advqmf_lat[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newtmpsum[j][i] = advqmf_lat[swindex[(j - 1)]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newtmpsum+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newtmpsum[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_2_2_info *data = (adv_run_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[12][260];
  
  double *_state_oldqv = data->state_oldqv;
  __attribute__ ((aligned (32))) double state_oldqv[12][260];
  
  double *_state_newtmpsum = data->state_newtmpsum;
  __attribute__ ((aligned (32))) double state_newtmpsum[12][260];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_le_lat = data->le_lat;
  __attribute__ ((aligned (32))) double le_lat[hny+2*hy];
  
  double *_area_cell = data->area_cell;
  __attribute__ ((aligned (32))) double area_cell[fny+2*hy];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  dmasize = hny + 2*hy;
  DMA_READ(_le_lat+(ghy-hy), &le_lat[0], dmasize* sizeof(double));
  dmasize = fny + 2*hy;
  DMA_READ(_area_cell+(ghy-hy), &area_cell[0], dmasize* sizeof(double));
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_newtmpsum[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib), &advold_m[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newtmpsum+(kb*fnumy*fnumx+j*fnumx+ib), &state_newtmpsum[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = ((advold_m[swindex[j]][i] * state_oldqv[swindex[j]][i]) + ((((state_newtmpsum[swindex[j]][i] * le_lat[(j+jb+oy - 1)]) / 2400) / area_cell[j+jb+oy]) * 30));
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_2_3(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_2_3_info *data = (adv_run_2_3_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (state_newqv[j][i] / state_oldm[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_2_6(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_2_6_info *data = (vflx_ppm_2_6_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[8][260];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[8][260];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[8][260];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[8][260];
  
  struct Vector3 buf;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            buf = slave_ppm(state_newqv[swindex[(k - 2)]][i],state_newqv[swindex[(k - 1)]][i],state_newqv[swindex[k]][i],state_newqv[swindex[(k + 1)]][i],state_newqv[swindex[(k + 2)]][i]);
            advqlx[k][i] = buf.x;
            advdqx[k][i] = buf.y;
            advq6x[k][i] = buf.z;
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advqlx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advdqx[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
          DMA_IWRITE(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advq6x[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void vflx_ppm_2_7(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  vflx_ppm_2_7_info *data = (vflx_ppm_2_7_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_advcflz = data->advcflz;
  __attribute__ ((aligned (32))) double advcflz[bz+2*hz][bx+2*hx];
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[bz+2*hz][bx+2*hx];
  
  double *_advwe = data->advwe;
  __attribute__ ((aligned (32))) double advwe[bz+2*hz][bx+2*hx];
  
  double *_advqlx = data->advqlx;
  __attribute__ ((aligned (32))) double advqlx[bz+2*hz][bx+2*hx];
  
  double *_advdqx = data->advdqx;
  __attribute__ ((aligned (32))) double advdqx[bz+2*hz][bx+2*hx];
  
  double *_advq6x = data->advq6x;
  __attribute__ ((aligned (32))) double advq6x[bz+2*hz][bx+2*hx];
  
  double *_advqmf_lev = data->advqmf_lev;
  __attribute__ ((aligned (32))) double advqmf_lev[bz+2*hz][bx+2*hx];
  
  int ci;
  double cf;
  double s1;
  double s2;
  double ds1;
  double ds2;
  double ds3;
  double cursum;
  int l;
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_advcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advcflz[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advwe+(k*fnumy*fnumx+jb*fnumx+ib), &advwe[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advqlx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advdqx[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advq6x[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_advcflz+(k*fnumy*fnumx+jb*fnumx+ib), &advcflz[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advwe+(k*fnumy*fnumx+jb*fnumx+ib), &advwe[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqlx+(k*fnumy*fnumx+jb*fnumx+ib), &advqlx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advdqx+(k*fnumy*fnumx+jb*fnumx+ib), &advdqx[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advq6x+(k*fnumy*fnumx+jb*fnumx+ib), &advq6x[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            ci = (int)(advcflz[swindex[k]][i]);
            cf = (advcflz[swindex[k]][i] - ci);
            if ((advcflz[swindex[k]][i] > 0))
            {
              s1 = (1.0 - cf);
              s2 = 1.0;
              ds1 = (s2 - s1);
              ds2 = (pow(s2,2) - pow(s1,2));
              ds3 = (pow(s2,3) - pow(s1,3));
              cursum = 0.0;
              for (l=(k - ci);l<((k - 1) + 1);l+=1){
                cursum = (cursum + state_newqv[swindex[l]][i]);
              }
              advqmf_lev[k][i] = ((advwe[swindex[k]][i] * (((cursum + (advqlx[swindex[((k - ci) - 1)]][i] * ds1)) + ((0.5 * advdqx[swindex[((k - ci) - 1)]][i]) * ds2)) + (advq6x[swindex[((k - ci) - 1)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflz[swindex[k]][i]);
            }
            else
            {
              if ((advcflz[swindex[k]][i] < 0))
              {
                s1 = 0.0;
                s2 = -cf;
                ds1 = (s2 - s1);
                ds2 = (pow(s2,2) - pow(s1,2));
                ds3 = (pow(s2,3) - pow(s1,3));
                for (l=k;l<(((k - ci) - 1) + 1);l+=1){
                  cursum = (cursum + state_newqv[swindex[l]][i]);
                }
                advqmf_lev[k][i] = ((-advwe[swindex[k]][i] * (((cursum + (advqlx[swindex[(k - ci)]][i] * ds1)) + ((0.5 * advdqx[swindex[(k - ci)]][i]) * ds2)) + (advq6x[swindex[(k - ci)]][i] * ((ds2 / 2.0) - (ds3 / 3.0))))) / advcflz[swindex[k]][i]);
              }
              else
              {
                advqmf_lev[k][i] = 0.0;
              }
            }
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib+hx), &advqmf_lev[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_2_4(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_2_4_info *data = (adv_run_2_4_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[8][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[8][260];
  
  double *_advqmf_lev = data->advqmf_lev;
  __attribute__ ((aligned (32))) double advqmf_lev[8][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange,krange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[bz+2*hz];
  const int ws  = bz+2*hz;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j,k;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (jb = ybeg; jb < yend; jb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (kb= zbeg; kb < zend ; kb+= bz)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        krange = MIN(kb+bz,zend) - kb;
        dmasize = (irange + 2*hx);
        
        if (kb == zbeg){
          for (k = kb ; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(k*fnumy*fnumx+jb*fnumx+ib), &state_oldm[k - kb][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &advqmf_lev[k - kb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + bz) % ws;
          for (k = kb + hz; k < MIN(kb + bz, zend) + 2 * hz ; k++){
            int pos = swindex[k - kb];
            DMA_IREAD(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(k*fnumy*fnumx+jb*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_advqmf_lev+(k*fnumy*fnumx+jb*fnumx+ib), &advqmf_lev[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (k = hz ; k < hz + krange ; k++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[k][i] = ((state_newqv[k][i] * state_oldm[swindex[k]][i]) - ((advqmf_lev[swindex[(k + 1)]][i] - advqmf_lev[swindex[k]][i]) * 30));
          }
        
        for (k = kb + hz  ; k < MIN(kb+ bz, zend) + hz ; k++){
          DMA_IWRITE(_state_newqv+(k*fnumy*fnumx+jb*fnumx+ib+hx), &state_newqv[k - kb][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void adv_run_2_5(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  adv_run_2_5_info *data = (adv_run_2_5_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_newqv = data->state_newqv;
  __attribute__ ((aligned (32))) double state_newqv[12][260];
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[12][260];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[j - jb][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib), &state_newqv[pos][0], dmasize* sizeof(double));
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            state_newqv[j][i] = (state_newqv[j][i] / state_oldm[swindex[j]][i]);
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_state_newqv+(kb*fnumy*fnumx+j*fnumx+ib+hx), &state_newqv[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}
void copy_old_m_2_2(void *_ptr){
  
  volatile int reply = 0;
  volatile int COUNT = 0;
  
  copy_old_m_2_2_info *data = (copy_old_m_2_2_info*)(_ptr);
  
  int lx = data->lx;
  int ly = data->ly;
  int lz = data->lz;
  int hx = data->hx;
  int hy = data->hy;
  int hz = data->hz;
  int ox = data->ox;
  int oy = data->oy;
  int oz = data->oz;
  int bx = data->bx;
  int by = data->by;
  int bz = data->bz;
  int mx = data->mx;
  int my = data->my;
  int mz = data->mz;
  
  
  double *_state_oldm = data->state_oldm;
  __attribute__ ((aligned (32))) double state_oldm[10][258];
  
  double *_advold_m = data->advold_m;
  __attribute__ ((aligned (32))) double advold_m[10][258];
  
  
  
  int zbeg,zend,zlen,ybeg,yend,ylen,xbeg,xend,xlen;
  int irange,jrange;
  int fnumx = fnx + 2*ghx;
  int fnumy = fny + 2*ghy;
  int hnumx = hnx + 2*ghx;
  int hnumy = hny + 2*ghy;
  
  int swindex[by+2*hy];
  const int ws  = by+2*hy;
  
  int id,rid,cid,w,e,s,n;
  int ib,jb,kb,i,j;
  int dmasize;
  
  CalcID(&id, &rid, &cid, &w, &e, &s, &n, mx, my);
  CalcRange(id,rid,cid,lx,ly,lz,mx,my,mz,&xbeg,&xend,&xlen,&ybeg,&yend,&ylen,&zbeg,&zend,&zlen);
  
  DMA_DECL_DESC(READ_WRITE);
  CRTS_ssync_array();
  
  
  for (kb = zbeg; kb < zend; kb++){
    for (i = 0; i < ws; i++) swindex[i] = i;
    
    for (jb= ybeg; jb < yend ; jb+= by)
      for (ib = xbeg; ib < xend; ib+= bx){
        irange = MIN(ib+bx,xend) - ib;
        jrange = MIN(jb+by,yend) - jb;
        dmasize = (irange + 2*hx);
        
        if (jb == ybeg){
          for (j = jb ; j < MIN(jb + by, yend) + 2 * hy ; j++){
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[j - jb][0], dmasize* sizeof(double));
          }
        }
        else{
          for (i = 0; i < ws; i++)
            swindex[i] = (swindex[i] + by) % ws;
          for (j = jb + hy; j < MIN(jb + by, yend) + 2 * hy ; j++){
            int pos = swindex[j - jb];
            DMA_IREAD(_state_oldm+(kb*fnumy*fnumx+j*fnumx+ib), &state_oldm[pos][0], dmasize* sizeof(double));
          }
        }
        
        DMA_WAIT_ALL;
        
        for (j = hy ; j < hy + jrange ; j++)
          for (i = hx ; i < hx + irange ; i++){
            advold_m[j][i] = state_oldm[swindex[j]][i];
          }
        
        for (j = jb + hy  ; j < MIN(jb+ by, yend) + hy ; j++){
          DMA_IWRITE(_advold_m+(kb*fnumy*fnumx+j*fnumx+ib+hx), &advold_m[j - jb ][hx], (dmasize - 2*hx) * sizeof(double));
        }
      }
  }
}


